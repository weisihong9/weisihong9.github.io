{"meta":{"title":"WeiSH's BLOG","subtitle":"MaTRix","description":"","author":"weisihong","url":"https://weisihong9.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-05-16T11:49:05.950Z","updated":"2023-05-20T13:09:31.547Z","comments":false,"path":"about/index.html","permalink":"https://weisihong9.github.io/about/index.html","excerpt":"","text":"Weisihong：生命科学与技术学院，健康与康复科学研究所的研究生 研究方向：信号预处理、EEG与fNIRS多模态融合、时频分析、脑网络功能连接算法、机器学习、统计分析"},{"title":"留言","date":"2023-05-21T15:13:23.000Z","updated":"2023-05-21T15:34:41.059Z","comments":true,"path":"guestbook/index.html","permalink":"https://weisihong9.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"项目仓库","date":"2023-05-21T15:34:31.651Z","updated":"2023-05-21T15:34:31.651Z","comments":false,"path":"repository/index.html","permalink":"https://weisihong9.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-05-16T11:48:57.934Z","updated":"2023-05-21T15:34:11.984Z","comments":false,"path":"categories/index.html","permalink":"https://weisihong9.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-21T15:34:49.343Z","updated":"2023-05-21T15:34:49.343Z","comments":false,"path":"tags/index.html","permalink":"https://weisihong9.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MNE_EEG","slug":"MNE_EEG","date":"2024-05-14T16:00:00.000Z","updated":"2024-05-16T01:30:04.417Z","comments":true,"path":"2024/05/15/MNE_EEG/","link":"","permalink":"https://weisihong9.github.io/2024/05/15/MNE_EEG/","excerpt":"","text":"目的：介绍用python的MNE预处理EEG数据，并绘制ERSP EEG analysis with MNE-Python This tutorial covers the basic EEG pipeline for event-related analysis: loading data, preprocessing, epoching, averaging, plotting, time-frequency analysis, and estimating cortical activity from sensor data. 一、实验范式 二、预处理 1. 加载package 1234567891011121314import osimport mneimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom mne.preprocessing import EOGRegressionfrom scipy.ndimage import gaussian_filter1dfrom mne.time_frequency import tfr_morletimport warningswarnings.filterwarnings(&#x27;ignore&#x27;)warnings.simplefilter(&#x27;ignore&#x27;)%matplotlib qt 2. 加载数据 1234path = &#x27;.\\\\EEG\\\\set\\\\&#x27;fileName = &quot;clench_right&quot;raw = mne.io.read_raw_eeglab(path + fileName + &#x27;.set&#x27;) raw.info 3. 设置眼电、心电、去除不要的channel 这里根据你自己的电极来设定 123pd.DataFrame(raw.ch_names) # 查看通道名称raw.set_channel_types(&#123;&#x27;HEOG&#x27;:&#x27;eog&#x27;, &#x27;VEOG&#x27;:&#x27;eog&#x27;&#125;) # 32导联，VEO垂直眼电，HEO水平眼电，ECG心电 # raw.pick(picks=&#x27;all&#x27;, exclude=[&#x27;TRIGGER&#x27;, &#x27;ECG&#x27;, &#x27;EMG&#x27;]) # 去除无用电极 4. 查看raw数据波形，关注信噪比，该数据是否可用【坏导插值】 4.0 查看raw波形，绘制psd 1234raw.plot(start=10, duration=1) # 从10s开始，窗口显示时长1splt.show()raw.plot_psd(fmin=0, fmax=250)plt.show() 4.1 挑选坏导 把认为是坏导的，鼠标左键点击一下变灰即可 12raw.plot(start=10, duration=1, title=&#x27;请选择需要插值的坏导&#x27;) # 从20s开始，窗口显示时长1splt.show() 4.2 插值坏导 12raw.load_data() # 默认情况下，MNE不会将数据加载到主内存以节约资源。插值需要加载原始数据。在构造函数或raw.load_data()中使用preload=True（或字符串）。raw.interpolate_bads() 5. 带通滤波：2 ~ 40 * 123raw_filter = raw.copy()raw_filter.load_data()raw_filter.filter(l_freq=2, h_freq=40, n_jobs=1) 6. 重参考 * 1raw_ref = raw_filter.copy() 6.1 双侧乳突参考 因为我在采集数据时，用的参考电极是M2，这里再次选择双侧乳突参考的原理参考这篇文章 123456&#x27;&#x27;&#x27; 1. 添加 M2，值为0 &#x27;&#x27;&#x27;# add new reference channel (all zero) 添加一个新的参考电极，值为0，这样选择M1，M2重参考，就相当于 1/2 M1啦raw_new_ref = mne.add_reference_channels(raw_ref, ref_channels=[&quot;M2&quot;])# raw_new_ref.plot()&#x27;&#x27;&#x27; 2. 双侧乳突重参考&#x27;&#x27;&#x27; raw_new_ref.set_eeg_reference(ref_channels=[&#x27;M1&#x27;, &#x27;M2&#x27;]) 6.2 平均参考 平均参考的话，一般放到ICA之后 1raw_ref.set_eeg_reference(ref_channels=&#x27;average&#x27;) 7. ICA去眼电 * 7.1 选取需要去除的ICA成分 12345678&#x27;&#x27;&#x27; 1. ICA，独立成分分析去除眼电和心电伪迹&#x27;&#x27;&#x27;ica = mne.preprocessing.ICA(n_components=20, max_iter=800) # 定义一个ICA方法ica.fit(raw_new_ref) # 训练ICA模型raw_new_ref.load_data()ica.plot_sources(raw_new_ref, show_scrollbars=True, title=&#x27;请选择需要去除的成分&#x27;) ica.plot_components()&#x27;&#x27;&#x27; 2. 对ICA之后的成分进行绘制，跟前面选择坏导方法一致 &#x27;&#x27;&#x27; plt.show() 7.2 ICA成分剔除 123456789&#x27;&#x27;&#x27; 3. 查看选择去除的成分个数 &#x27;&#x27;&#x27; print(ica)raw_ICA = raw_new_ref.copy()&#x27;&#x27;&#x27; 4. 去除刚刚选择的伪迹成分 &#x27;&#x27;&#x27;raw_ICA = ica.apply(raw_ICA) &#x27;&#x27;&#x27; 5. ICA去除前后波形比较&#x27;&#x27;&#x27; raw_new_ref.plot(start=1, duration=5, title=&#x27;ICA处理前，如无误请关闭窗口&#x27;)raw_ICA.plot(start=1, duration=5, title=&#x27;ICA处理后，如无误请关闭窗口&#x27;)plt.show() 8. 通道定位 * 这一步一般不需要，只不过是因为我的电极重新布置了，所以得重新定位 自定义电极位置，需要自定义电极布局文件对数据进行通道定位可以查看这篇文章。 12345678910111213141516171819202122232425262728293031# 查看通道名称raw_ICA_rename = raw_ICA.copy()raw_ICA_rename.pick(picks=&#x27;all&#x27;, exclude=[&#x27;M1&#x27;, &#x27;M2&#x27;,&#x27;HEOG&#x27;,&#x27;VEOG&#x27;])# pd.DataFrame(raw_ICA_rename.ch_names)raw_chName = raw_ICA_rename.ch_namesrename_chName = &#123;&#125;for ch in raw_chName: if ch == &#x27;T7&#x27;: rename_chName[ch] = &#x27;C5&#x27; elif ch == &#x27;TP7&#x27;: rename_chName[ch] = &#x27;CP5&#x27; elif ch == &#x27;T8&#x27;: rename_chName[ch] = &#x27;C6&#x27; elif ch == &#x27;TP8&#x27;: rename_chName[ch] = &#x27;CP6&#x27; else: rename_chName[ch] = ch&#x27;&#x27;&#x27; 1. 通道重命名 &#x27;&#x27;&#x27;raw_ICA_rename.rename_channels(rename_chName)&#x27;&#x27;&#x27; 2. 加载定位文件&#x27;&#x27;&#x27;myStardart1020 = pd.read_excel(&#x27;sensor_dataFrame_32.xlsx&#x27;, index_col=0) ch_names = np.array(myStardart1020.index) # 电极名称position = np.array(myStardart1020) # 电极坐标位置sensorPosition = dict(zip(ch_names, position)) # 制定为字典的形式montage = mne.channels.make_dig_montage(ch_pos=sensorPosition)&#x27;&#x27;&#x27; 3. 通道定位 &#x27;&#x27;&#x27;raw_ICA_rename.set_montage(montage) 9. 保存预处理后的数据 12sub = &#x27;sub1_&#x27;raw_ICA_rename.save(&quot;.//1_preProcessData//&quot;+ sub +fileName+&quot;_M1reRef_preP-eeg.fif&quot;, overwrite = False) 三、提取epoch，evoked * 1. 绘制events图 1234events, event_dict = mne.events_from_annotations(raw_ICA_rename)event_id = &#123;&#x27;Fix&#x27;:event_dict[&#x27;1&#x27;], &#x27;task&#x27;:event_dict[&#x27;3&#x27;],&#x27;Rest&#x27;:event_dict[&#x27;5&#x27;]&#125; # marker类型由自己的范式任务决定plt.rcParams[&#x27;figure.figsize&#x27;]=(7, 5)mne.viz.plot_events(events, event_id=event_id, sfreq=raw.info[&quot;sfreq&quot;]) 2. 根据marker提取epoch 1234567891011121314events = mne.events_from_annotations(raw_ICA_rename)event_dic = &#123;&#x27;Fix&#x27;:events[1][&#x27;1&#x27;], &#x27;task&#x27;:events[1][&#x27;3&#x27;], &#x27;Rest&#x27;:events[1][&#x27;5&#x27;]&#125; # reject_criteria = dict(eeg=100e-6) # 幅度大于100微幅的不要，这个可要可不要，即振幅过大就去除epochs = mne.Epochs(raw_ICA_rename, events[0], event_id=event_dic, preload=True, tmax=20, tmin=-10, # 刺激前10s，刺激后20s # reject=reject_criteria, baseline = None, # 要做ERSP，提取epoch时不需要基线矫正 baseline= (-2,0) ) epochs 3. 目视并手动去除伪迹依然严重的epoch 123task_epochs = epochs[&#x27;task&#x27;]task_epochs.plot(title=&quot;请目视挑出坏epochs&quot;)plt.show() 4. 绘制evoked时域波形 123task_evoked = task_epochs.average()task_evoked.plot(picks=[&#x27;C3&#x27;,&#x27;C4&#x27;], xlim=(-2,2))plt.show() 5. 绘制evoked的psd 123456789task_evoked.crop(0,12).plot_psd(fmin=2, fmax=30, picks=[&#x27;C3&#x27;, &#x27;C4&#x27;], # method = &#x27;welch&#x27;, xscale=&#x27;linear&#x27;, dB=False, estimate=&#x27;amplitude&#x27;, )plt.title(sub + fileName) 6. 绘制evoked某一时刻的脑地形图 只能选择某一时刻 参考：https://mne.tools/dev/auto_examples/visualization/evoked_topomap.html#sphx-glr-auto-examples-visualization-evoked-topomap-py 12times = np.arange(-2, 14, 2)task_evoked.plot_topomap(times, ch_type=&quot;eeg&quot;, ncols=4, nrows=&quot;auto&quot;) 四. 绘制ERSP * 要计算ERSP，提取epoch时不需要基线矫正。 ERSP：反映了信号中不同频率的功率相对于特定时间点（例如信号出现）的变化程度。 事件相关同步化/去同步化：event-related synchronization / desynchronization （ERS/ERD） ERD 对应于特定频带内的功率相对于基线的降低。类似地，ERS 对应于功率的增加。 ERDS 图是 ERD/ERS 在一定频率范围内的时间/频率表示形式。 ERDS 地图也称为 ERSP（事件相关频谱扰动：event-related spectral perturbation， ERSP）。 参考：https://zh-1-peng.gitbook.io/eeg-analysis-note/ersp 1. 定义小波函数计算时频谱 参考：https://mne.tools/stable/auto_tutorials/time-freq/20_sensors_time_frequency.html#sphx-glr-auto-tutorials-time-freq-20-sensors-time-frequency-py 1234567891011121314151617from mne.time_frequency import tfr_morletfreqs = np.logspace(*np.log10([2, 40]), num=80)n_cycles = freqs / 2.0 # different number of cycle per frequency# 1. 定义函数def getPSD(dataEpochs): power1, itc = tfr_morlet( dataEpochs, freqs=freqs, n_cycles=n_cycles, use_fft=True, return_itc=True, decim=3, n_jobs=1,) return power1, itc# 2. 计算task_power, itc = getPSD(task_epochs) 2. 绘制单通道ERSP mode：‘mean’ | ‘ratio’ | ‘logratio’ | ‘percent’ | ‘zscore’ | ‘zlogratio’ Perform baseline correction by subtracting the mean of baseline values (‘mean’) dividing by the mean of baseline values (‘ratio’) dividing by the mean of baseline values and taking the log (‘logratio’) subtracting the mean of baseline values followed by dividing by the mean of baseline values (‘percent’) subtracting the mean of baseline values and dividing by the standard deviation of baseline values (‘zscore’) dividing by the mean of baseline values, taking the log, and dividing by the standard deviation of log baseline values (‘zlogratio’) 1234567891011121314151617181920def plotTF(taskPower, tmin1, tmax1, ch, fn): # ch：需要绘制的导联名称 # 绘制时频图 taskPower.plot( picks = task_power.ch_names.index(ch), baseline=(-7, -3), # 这里我选择基线是（-7~-3），后面的power都减去基线的均值。表示：所有特定频带内的功率相对于基线（-7，-3）的变化程度 mode=&quot;percent&quot;, # 具体含义参考上面的解释 tmin=tmin1, tmax=tmax1, vmin=-1, vmax=1, show=False, colorbar=True, # cmap=&#x27;jet&#x27;, ) plt.ylim([0, 40]) plt.suptitle(ch) plt.savefig(&quot;.//1_preProcessData//TFA//&quot;+fn+ch, dpi=600) # 保存绘制的TF# 绘制fn = sub+ fileNameplotTF(task_power, -10, 20, &#x27;C3&#x27;, fn) 可以发现在任务时期，0~8s内，alpha频段的能量相较于基线明显下降，这是明显的ERD现象。 3. 绘制所有通道的ERSP 1task_power.plot_topo(baseline=(-7, -3), mode=&#x27;percent&#x27;, vmin=-1, vmax=1, title=&quot;Average power&quot;) # mode=&quot;logratio&quot; 4. 保存计算的时频谱 1234import picklewith open(&#x27;task_power.pkl&#x27;, &#x27;wb&#x27;) as f: pickle.dump(task_power, f) 5. 加载保存好的时频谱 12with open(&#x27;task_power.pkl&#x27;, &#x27;rb&#x27;) as f: task_power = pickle.load(f) 6. 时间进程上特定频段power的变化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def getPowerDataFrameTime(power_task, ch_pair): freqs = np.arange(2, 40) # frequencies from 2-35Hz # vmin, vmax = -1, 1.5 # set min and max ERDS values in plot baseline = (-7, -3) # baseline interval (in s) tmin, tmax = -7, 20 &#x27;&#x27;&#x27; ERSD： percent： 减去基线值的平均值，再除以基线值的平均值（&quot;百分比） &#x27;&#x27;&#x27; power_task.crop(tmin, tmax).apply_baseline(baseline, mode=&quot;percent&quot;) &#x27;&#x27;&#x27; 0. 字典形式 &#x27;&#x27;&#x27; df = power_task.to_data_frame(time_format=None, long_format=True) &#x27;&#x27;&#x27; 1. 选择感兴趣的通道 &#x27;&#x27;&#x27; new_categories = ch_pair df = df[df.channel.isin(new_categories)] df[&quot;channel&quot;] = df[&quot;channel&quot;].cat.remove_unused_categories() df[&quot;channel&quot;] = df[&quot;channel&quot;].cat.reorder_categories(new_categories, ordered=True) &#x27;&#x27;&#x27; 2. 选择感兴趣的频段 &#x27;&#x27;&#x27; freq_bounds = &#123;&quot;_&quot;: 0, &quot;delta&quot;: 4, &quot;theta&quot;: 8, &quot;alpha&quot;: 13, &quot;beta&quot;: 30, &quot;gamma&quot;:40&#125; df[&quot;band&quot;] = pd.cut( df[&quot;freq&quot;], list(freq_bounds.values()), labels=list(freq_bounds)[1:] ) freq_bands_of_interest = [&quot;alpha&quot;,&quot;beta&quot;] # &quot;delta&quot;, &quot;theta&quot;,, &quot;beta&quot;, &quot;gamma&quot; df = df[df.band.isin(freq_bands_of_interest)] df[&quot;band&quot;] = df[&quot;band&quot;].cat.remove_unused_categories() return df# 1. 选择感兴趣的通道ch_pairs = [&#x27;C3&#x27;, &#x27;CZ&#x27;, &#x27;C4&#x27;]# 2. 获取统计的DataFrametask_power_time = getPowerDataFrameTime(task_power.copy(), ch_pairs)# 3. 绘图g = sns.FacetGrid(task_power_time, row=&quot;band&quot;, margin_titles=True)g.map(sns.lineplot, &quot;time&quot;, &quot;value&quot;, &quot;channel&quot;, n_boot=10, linewidth=2)axline_kw = dict(color=&quot;black&quot;, linestyle=&quot;dashed&quot;, linewidth=0.5, alpha=0.5)g.map(plt.axhline, y=0, **axline_kw)g.map(plt.axvline, x=0, **axline_kw)g.refline(x=0, color=&#x27;red&#x27;)g.refline(y=0, color=&#x27;red&#x27;)g.set(ylim=(-0.9, 0.9))g.set_axis_labels(&quot;Time (s)&quot;, &quot;ERDS&quot;)g.set_titles(col_template=&quot;&#123;col_name&#125;&quot;, row_template=&quot;&#123;row_name&#125;&quot;)g.add_legend(ncol=3, loc=&quot;lower center&quot;)g.fig.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.08) 另一种画法 12345678910111213g = sns.FacetGrid(task_power_time, row=&quot;band&quot;, col=&quot;channel&quot;, margin_titles=True)g.map(sns.lineplot, &quot;time&quot;, &quot;value&quot;, n_boot=10, linewidth=2)axline_kw = dict(color=&quot;black&quot;, linestyle=&quot;dashed&quot;, linewidth=0.5, alpha=0.5)g.map(plt.axhline, y=0, **axline_kw)g.map(plt.axvline, x=0, **axline_kw)g.refline(x=0, color=&#x27;red&#x27;)g.refline(y=0, color=&#x27;red&#x27;)g.set(ylim=(-0.9, 0.9))g.set_axis_labels(&quot;Time (s)&quot;, &quot;ERDS&quot;)g.set_titles(col_template=&quot;&#123;col_name&#125;&quot;, row_template=&quot;&#123;row_name&#125;&quot;)g.add_legend(ncol=2, loc=&quot;lower center&quot;)g.fig.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.08) 7. 频段进程上特定时间段power的变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def getPowerDataFrameBand(power_task, ch_pair): freqs = np.arange(2, 40) # frequencies from 2-35Hz # vmin, vmax = -1, 1.5 # set min and max ERDS values in plot baseline = (-7, -3) # baseline interval (in s) tmin, tmax = -7, 20 &#x27;&#x27;&#x27; 基线 &#x27;&#x27;&#x27; power_task.crop(tmin, tmax).apply_baseline(baseline, mode=&quot;percent&quot;) &#x27;&#x27;&#x27; 0. 字典形式 &#x27;&#x27;&#x27; df = power_task.to_data_frame(time_format=None, long_format=True) &#x27;&#x27;&#x27; 1. 选择感兴趣的通道 &#x27;&#x27;&#x27; new_categories = ch_pair df = df[df.channel.isin(new_categories)] df[&quot;channel&quot;] = df[&quot;channel&quot;].cat.remove_unused_categories() df[&quot;channel&quot;] = df[&quot;channel&quot;].cat.reorder_categories(new_categories, ordered=True) &#x27;&#x27;&#x27; 2. 选择感兴趣的时间段 &#x27;&#x27;&#x27; df_mean = (df.query(&quot;time &gt; 1 &amp; time &lt; 7&quot;) .groupby([&quot;channel&quot;,&quot;freq&quot;], observed=False)[[&quot;value&quot;]] .mean() .reset_index() ) return df_mean# 计算ch_pairs = [&#x27;C3&#x27;, &#x27;C4&#x27;]task_power_band = getPowerDataFrameBand(task_power.copy(), ch_pairs)task_power_band# 绘制g = sns.FacetGrid(task_power_band, margin_titles=True)g.map(sns.lineplot, &quot;freq&quot;, &quot;value&quot;, &quot;channel&quot;,n_boot=10, linewidth=2)axline_kw = dict(color=&quot;black&quot;, linestyle=&quot;dashed&quot;, linewidth=0.5, alpha=0.5)g.map(plt.axhline, y=0, **axline_kw)g.map(plt.axvline, x=0, **axline_kw)g.refline(x=0, color=&#x27;red&#x27;)g.refline(y=0, color=&#x27;red&#x27;)# g.set(ylim=(None, 0.5))g.set_axis_labels(&quot;Frequency (Hz)&quot;, &quot;ERDS&quot;)g.set_titles(col_template=&quot;&#123;col_name&#125;&quot;, row_template=&quot;&#123;row_name&#125;&quot;)g.add_legend(ncol=3, loc=&quot;upper center&quot;)g.fig.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.08) 8. 绘制ERSD Map 可以选择频段和时间区间 123456789101112131415161718192021def plotTopoMap(taskPower, tmin1, tmax1, fn): # topomap_args = dict(extrapolate=&quot;local&quot;) &#x27;&#x27;&#x27; 1. 选择感兴趣的频段 &#x27;&#x27;&#x27; plot_dict = dict(Alpha=dict(fmin=9, fmax=12)) &#x27;&#x27;&#x27; 2. 选择感兴趣的时间区间：tmin1, tmax1 &#x27;&#x27;&#x27; topomap_kw = dict(tmin=tmin1, tmax=tmax1, baseline=(-7, -3), mode=&quot;percent&quot;, show=False) for (title, fmin_fmax) in plot_dict.items(): taskPower.plot_topomap(**fmin_fmax, # cmap=&#x27;Pastel1&#x27;, # vlim=(-0.7, 0.7), **topomap_kw, # **topomap_args ) plt.suptitle(str(tmin1) +&#x27;_&#x27;+ str(tmax1)+&#x27;s_8-11Hz&#x27;) plt.savefig(&quot;.//1_preProcessData//TopoMap//&quot;+fn, dpi=600) fn1 = sub + fileNameplotTopoMap(taskPower=task_power, tmin1=0, tmax1=7, fn=fn1) 以上就是从EEG预处理到绘制ERSP的全部过程，这里考虑了很多情况，步骤有点多，如果想要修改但不知道怎么改的可以给我留言哦。","categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"},{"name":"ERSP","slug":"EEG/ERSP","permalink":"https://weisihong9.github.io/categories/EEG/ERSP/"}],"tags":[{"name":"ERSP","slug":"ERSP","permalink":"https://weisihong9.github.io/tags/ERSP/"}]},{"title":"BrainNetwork","slug":"BrainNetwork","date":"2023-11-23T16:00:00.000Z","updated":"2023-11-24T02:48:05.727Z","comments":true,"path":"2023/11/24/BrainNetwork/","link":"","permalink":"https://weisihong9.github.io/2023/11/24/BrainNetwork/","excerpt":"","text":"目的：利用matlab工具包 BrainNet Viewer 绘制脑网络图 1. BrainNet Viewer 的主要功能 脑网络的多视角显示 显示多种脑曲面、节点和边构成的不同组合 多种方式调节点、边的颜色和大小 自定阈值来提取相关矩阵中的边信息 实现体素图像到曲面的映射 可进行放大、缩小、旋转等交互式操作 支持jpg、png等多种格式的输出 2. BrainNet Viewer 的安装 去官网下载BrianNet Viewer工具包放到自己电脑的文件夹里。 因为BrianNet Viewer是基于Matlab的，故只需要在Matlab的路径里面添加BrianNet Viewer的文件路径即可。 3. BrainNet Viewer 的使用 1）打开Matlab，在命令行窗口输入：BrainNet 2）进入BrainNet Viewer界面 3）BN类型 BrainNet Viewer可以产生多种组合图（如下图），因为我做的是EEG，所以常用的是第5种，后面我们会详细介绍此种图的画法，也简单介绍第9种。 4. 脑网络绘制流程 读入文件 设置绘图格式 脑网络图显示 结果导出 调整node label 1）读入文件 1 脑曲面文件（Surface file）：ASCII文件，后缀名为‘nv’，包含了脑曲面上的顶点和三角曲面信息 2 节点文件（node file）：ASCII文件，后缀名为’node’，为nx6的矩阵，包含了节点的坐标、颜色、大小和标签信息 3 边文件（edge file）：ASCII文件，后缀名为‘edge’，为nxn矩阵，即节点间的相关矩阵 4 三维图像文件（volume file）：NIFTI或Analyze格式，后缀名为配对的‘hdr’和‘img’该文件仅用于体素到曲面的映射绘制 [x] File —&gt; Load File 文件说明 a）Surface file a）Node file a）Edge file 2）设置绘图格式 1 带label的图：前面导入文件添加完路径点击‘ok’按钮之后会出现右图的界面，选择 Node --&gt; Label All --&gt; Colomap 点击‘ok’即可画出脑网络连接图。 2 选择Colomap画出来的节点颜色会根据你node文件节点颜色部分来分配。 3 如果选择Modular，可以根据node文件节点颜色序号来自定义节点颜色。 4 不带label的图：只需把Label ALL 变成 Label None即可 3）脑网络图显示 4）结果导出 5）调整node label 5. ROI 的绘制 参考：AAL模板及脑区功能介绍 关于BrainNet Viewer的更多具体使用可以参考BrainNet_Manual.pdf","categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"},{"name":"FBN","slug":"EEG/FBN","permalink":"https://weisihong9.github.io/categories/EEG/FBN/"}],"tags":[{"name":"FBN","slug":"FBN","permalink":"https://weisihong9.github.io/tags/FBN/"}]},{"title":"DiGraph","slug":"DiGraph","date":"2023-10-24T16:00:00.000Z","updated":"2023-10-25T12:59:19.571Z","comments":true,"path":"2023/10/25/DiGraph/","link":"","permalink":"https://weisihong9.github.io/2023/10/25/DiGraph/","excerpt":"","text":"目的：绘制加权有向连接图 1. 用连接边的颜色表示两个节点之间的强度 2. 用边的权重来表示节点连接的强度 参考： https://networkx.org/documentation/stable/auto_examples/drawing/plot_directed.html https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html 0. 加载python库 1234import matplotlib.pyplot as pltimport networkx as nximport matplotlib as mplimport numpy as np 1. 用连接边的颜色表示两个节点之间的强度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#x27;&#x27;&#x27;0. 自己的权重值矩阵&#x27;&#x27;&#x27;value_new=[[0.,0.,0.,0.,0.,0.,0.,0.013], [0.,0.,0.,0.,0.,0.,0.,0.013], [0.,0.,0.,0.,0.,0.,0.,0.013], [0.,0.,0.,0.,0.,0.,0.,0.], [0.,0.,0.,0.,0.,0.,0.,0.], [0.,0.,0.,0.,0.,0.,0.005,0.], [0.,0.,0.,0.,0.,0.007,0.,0.008], [0.011,0.013,0.,0.012,0.,0.01,0.009,0.016]]&#x27;&#x27;&#x27; 1. 初始化图&#x27;&#x27;&#x27; G = nx.MultiDiGraph()pos = nx.spring_layout(G)# 设置节点名称row = np.array([&#x27;FL&#x27;,&#x27;FM&#x27;,&#x27;FR&#x27;,&#x27;TL&#x27;,&#x27;TR&#x27;,&#x27;C&#x27;,&#x27;P&#x27;,&#x27;O&#x27;])G.add_nodes_from([&#x27;FL&#x27;,&#x27;FM&#x27;,&#x27;FR&#x27;,&#x27;TL&#x27;,&#x27;TR&#x27;,&#x27;C&#x27;,&#x27;P&#x27;,&#x27;O&#x27;])&#x27;&#x27;&#x27; 2. 将节点的连接边权重加入构建的图&#x27;&#x27;&#x27;for j in range(0,8): for i in range(0,8): if value_new[i][j] != 0: G.add_weighted_edges_from([(row[j],row[i],value_new[i][j])])#边的起点，终点，权重 else: pass &#x27;&#x27;&#x27; 3. 节点的设置 &#x27;&#x27;&#x27; # 节点大小 node_sizes = [1000,1000,1000,1000,1000,1000,1000,1000]# 节点颜色node_color = [&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;]# 设置节点位置pos=&#123;&#x27;FL&#x27;:(38,75),&#x27;FM&#x27;:(40,80),&#x27;FR&#x27;:(42,75), &#x27;TL&#x27;:(37,64),&#x27;C&#x27;:(40,65), &#x27;TR&#x27;:(43,64), &#x27;P&#x27;:(38,53),&#x27;O&#x27;:(42,53)&#125;&#x27;&#x27;&#x27; 4. 边的颜色: 用连接边的颜色表示两个节点之间的强度/ 可以用边的权重来表示节点连接的强度 &#x27;&#x27;&#x27;edge_colors=[float(v[&#x27;weight&#x27;]) for (r,c,v) in G.edges(data=True)] cmap = plt.cm.jet # jet、viridis、plasma、inferno、magma、cividis...&#x27;&#x27;&#x27; 5. 绘图 &#x27;&#x27;&#x27; # 绘制节点nx.draw_networkx_nodes(G,pos, node_size=node_sizes, #node_color=node_color, alpha=0.4 )# 节点字体大小nx.draw_networkx_labels(G,pos,font_size=15)# 绘制连接边edges = nx.draw_networkx_edges(G,pos, edge_color = edge_colors, #alpha=0.5, # 透明度 edge_cmap = cmap, connectionstyle=&#x27;arc3, rad = 0.25&#x27;, # arc控制双向，rad调线条弧度 width=5, )pc = mpl.collections.PatchCollection(edges, cmap=cmap)# 显示colorbarpc.set_array(edge_colors)ax = plt.gca()ax.set_axis_off()plt.colorbar(pc, ax=ax)# 保存图片plt.title(&#x27;Weighted directed connected graph (colour of edges)&#x27;)plt.savefig(&quot;CE_Graph.png&quot;,dpi=600, bbox_inches=&#x27;tight&#x27;)plt.show() 2. 用边的权重来表示节点连接的强度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#x27;&#x27;&#x27;0. 自己的权重值矩阵&#x27;&#x27;&#x27;value_new=[[0.,0.,0.,0.,0.,0.,0.,0.013], [0.,0.,0.,0.,0.,0.,0.,0.013], [0.,0.,0.,0.,0.,0.,0.,0.013], [0.,0.,0.,0.,0.,0.,0.,0.], [0.,0.,0.,0.,0.,0.,0.,0.], [0.,0.,0.,0.,0.,0.,0.005,0.], [0.,0.,0.,0.,0.,0.007,0.,0.008], [0.011,0.013,0.,0.012,0.,0.01,0.009,0.016]]&#x27;&#x27;&#x27; 1. 初始化图&#x27;&#x27;&#x27; G = nx.MultiDiGraph()pos = nx.spring_layout(G)row = np.array([&#x27;FL&#x27;,&#x27;FM&#x27;,&#x27;FR&#x27;,&#x27;TL&#x27;,&#x27;TR&#x27;,&#x27;C&#x27;,&#x27;P&#x27;,&#x27;O&#x27;])G.add_nodes_from([&#x27;FL&#x27;,&#x27;FM&#x27;,&#x27;FR&#x27;,&#x27;TL&#x27;,&#x27;TR&#x27;,&#x27;C&#x27;,&#x27;P&#x27;,&#x27;O&#x27;])&#x27;&#x27;&#x27; 2. 将节点的连接边权重加入构建的图&#x27;&#x27;&#x27;for j in range(0,8): for i in range(0,8): if value_new[i][j] != 0: G.add_weighted_edges_from([(row[j],row[i],value_new[i][j]*300)]) # 边的起点，终点，权重 ，因为我的权重实在太小了，所以整体扩大300倍 else: pass &#x27;&#x27;&#x27; 3. 节点的设置 &#x27;&#x27;&#x27; # 节点大小 node_sizes = [1000,1000,1000,1000,1000,1000,1000,1000]# 节点颜色node_color = [&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;,&#x27;g&#x27;]# 设置节点位置pos=&#123;&#x27;FL&#x27;:(38,75),&#x27;FM&#x27;:(40,80),&#x27;FR&#x27;:(42,75), &#x27;TL&#x27;:(37,64),&#x27;C&#x27;:(40,65), &#x27;TR&#x27;:(43,64), &#x27;P&#x27;:(38,53),&#x27;O&#x27;:(42,53)&#125;&#x27;&#x27;&#x27; 4. 边的颜色: 用连接边的颜色表示两个节点之间的强度/ 可以用边的权重来表示节点连接的强度 &#x27;&#x27;&#x27;weight=[float(v[&#x27;weight&#x27;]) for (r,c,v) in G.edges(data=True)] &#x27;&#x27;&#x27; 5. 绘图 &#x27;&#x27;&#x27; # 绘制节点nx.draw_networkx_nodes(G,pos, node_size=node_sizes, #node_color=node_color, alpha=0.4 )# 节点字体大小nx.draw_networkx_labels(G,pos,font_size=15)# 绘制连接边edges = nx.draw_networkx_edges(G,pos, edge_color = &#x27;lightseagreen&#x27;, #alpha=0.5, # 透明度 edge_cmap = cmap, connectionstyle=&#x27;arc3, rad = 0.25&#x27;, # arc控制双向，rad调线条弧度 width=weight )# 保存图片plt.savefig(&quot;SE_Graph.png&quot;,dpi=600, bbox_inches=&#x27;tight&#x27;)plt.show()","categories":[{"name":"Graph","slug":"Graph","permalink":"https://weisihong9.github.io/categories/Graph/"},{"name":"EEG","slug":"Graph/EEG","permalink":"https://weisihong9.github.io/categories/Graph/EEG/"}],"tags":[{"name":"BEAM","slug":"BEAM","permalink":"https://weisihong9.github.io/tags/BEAM/"}]},{"title":"CrossFrequencyCoupling","slug":"CrossFrequencyCoupling","date":"2023-07-05T05:00:49.000Z","updated":"2023-07-06T08:00:48.066Z","comments":true,"path":"2023/07/05/CrossFrequencyCoupling/","link":"","permalink":"https://weisihong9.github.io/2023/07/05/CrossFrequencyCoupling/","excerpt":"","text":"目的：介绍跨频耦合的背景及常用的计算方法 1、背景 神经科学的核心问题之一是神经活动如何在不同的空间和时间尺度上协调。 跨频率耦合(Cross-frequency coupling, CFC) 已被提出在时间和空间尺度上协调神经动力学。 时间尺度：神经振荡之间的相幅耦合。例如，低频振荡的相位可以影响高频振荡的振幅，从而调节神经活动的时序，实现信息处理和集成。 空间尺度：神经振荡之间的空间耦合。例如，不同频率范围内的神经振荡可以在不同脑区之间相互调节，形成神经网络，实现信息的传递和整合。 EEG信号的CFC是指不同频率范围内的神经振荡之间存在相互调节和交互作用的现象。换句话说，CFC实际上是不同频带EEG的幅度/频率/相位之间的关系。常见的耦合关系如下：【慢震荡（Slow Oscillation，SO）；快震荡（ Fast Oscillation，FO ）】 相位-幅度耦合(phase-amplitude coupling，PAC)：SO的相位与FO幅度之间的耦合，也称为“嵌套”。目前研究比较多的是θ - γ和α - γ之间的PAC。 相位-频率耦合(phase- frequency coupling，PFC)：SO的相位和FO的频率之间的耦合。 相位-相位耦合(phase-phase coupling，PPC)：SO和FO相位之间的耦合。 2、CFC在神经疾病中的应用 跨频耦合作为一种神经机制，在多种神经疾病中都得到了广泛研究： 癫痫：研究表明[1]， 跨频频率耦合是定位癫痫组织的有用生物标志物。 帕金森病：研究表明[2]，theta-gamma跨频耦合可以作为帕金森疾病的生物标志，并有助于对帕金森疾病的早期诊断和治疗进行监测。 精神分裂症：研究表明[3]， theta-gamma跨频耦合减弱与认知障碍症状的严重程度有关。 抑郁症：研究表明[4]，抑郁症患者与健康对照组相比，前额叶皮层的theta-gamma跨频耦合存在显著差异。 3、CFC常用计算方法 [5] 锁相值（phase-locking value，PLV） 平均向量长度（mean vector length，MVL） 调制指数（modulation index，MI） 3.1 锁相值（phase-locking value，PLV） 定义：PLV通过比较两个信号的相位差来评估它们之间的同步性。如果两个信号存在相位-幅度耦合，那么高频时间序列的振幅将在低频振荡。 计算步骤 计算公式 PLV=∣∑t=1nei(θlt−θut)n∣PLV=|\\frac{ {\\sum_{t=1}^{n}{e^{i(\\theta _{lt}-\\theta _{ut})} } } }{n}| PLV=∣n∑t=1n​ei(θlt​−θut​)​∣ 其中 n：数据点总数 t：时间数据点 θlt：t时刻的低频相位角 θut：希尔伯特变换后的高频振幅时间序列在t时刻的相位角 优点和缺点： 优点：受噪声影响小。 缺点：希尔伯特转换后的振幅时间序列不一定是窄带振荡。 python代码实现： 1234567# 利用PLV计算相幅耦合def PLV_CFC_WSH(phase, amp): # phase：低频信号的相位 # amp：高频信号的振幅 amp_phi = np.angle(hilbert(amp)) # 高频信号振幅的相位 observed_plv = np.abs(np.sum(np.exp(1j*(phase - amp_phi)))/len(phase)) return observed_plv 3.2 平均向量长度（mean vector length，MVL） 定义：MVL是一个向量集合中各个向量长度的平均值，它提供了对向量集合整体大小或幅度的一种度量。在CFC的计算中，将对应时刻的低频信号的相位角作为向量的方向，高频信号的振幅作为向量的幅度。 计算步骤： 计算公式： MVL=∣∑t=1nateiθtn∣MVL=\\left | \\frac{ {\\textstyle \\sum_{t=1}^{n}{a_{t} e^{i\\theta _{t}} } } }{n}\\right | MVL=∣∣∣∣∣​n∑t=1n​at​eiθt​​∣∣∣∣∣​ 其中: n：数据点总数 t：时间数据点 at：高频振幅时间序列在t时刻的幅值 θt：低频相位时间序列在t时刻的相位角 优点和缺点： 优点：对于长数据段，高采样率，高信噪比的信号，建议使用MVL。 缺点： MVL的计算受到频率振幅的整体幅度影响。如果某个频率的振幅较大，那么它将在计算MVL时有更大的权重。这可能会导致对整个向量集合大小或幅度的评估存在一定的偏差。 振幅异常值可能会强烈影响平均向量长度。 不同向量之间的相位角差异可能会影响平均向量长度的计算结果。 python代码实现： 1234567# 利用MVL计算相幅耦合def MVL_CFC_WSH(phase, amp): # phase：低频信号的相位 # amp：高频信号的振幅 amp_nor = (amp - np.min(amp)) / (np.max(amp) - np.min(amp)) # 振幅归一化 observed_mvl = np.abs(np.mean(amp_nor * np.exp(1j*phase))) return observed_mvl 3.3 调制指数（modulation index，MI） 定义：MI通过计算幅度和相位的熵来估计幅度调制指数。 计算步骤： 计算公式： p(j)=aˉ∑k=1Naˉk\\begin{aligned}p(j)=\\frac{\\bar{a} }{ {\\textstyle \\sum_{k=1}^{N}} \\bar{a} _{k}} \\end{aligned} p(j)=∑k=1N​aˉk​aˉ​​ ā为单个bin的平均振幅，k为bins的运行指数，N为bins的总数；p是一个有N个值的向量；H(p)为香农熵。 H(p)=−∑j=1Np(j)logp(j)KL(U,X)=logN−H(p)MI=KL(U,X)logN\\begin{aligned} H(p)=- {\\textstyle \\sum_{j=1}^{N}p(j)logp(j)}\\\\ KL(U,X)=logN-H(p)\\\\ MI=\\frac{KL(U,X)}{logN} \\end{aligned} H(p)=−∑j=1N​p(j)logp(j)KL(U,X)=logN−H(p)MI=logNKL(U,X)​​ U为均匀分布，X为数据分布。 KL(U, K): KL散度描述了用均匀分布U来估计数据的真实分布X的编码损失。 优点和缺点： 优点： 归一化熵是一种常用的信号复杂性度量，可以反映信号的不确定性和信息丰富度。 对于更短的数据，更低的采样率，更高噪声的数据，建议使用MI。 MI是使用最多的CFC方法。 缺点： 4. 依赖于特定的熵测量方法； 5. 对数据预处理的要求较高； python代码实现： 12345678910111213141516# 利用MI计算相幅耦合def MI_CFC_WSH(phase, amp, nbins): # phase：低频信号的相位 # amp：高频信号的振幅 # nbins：划分的箱子数 bins = np.linspace(-np.pi, np.pi, nbins+1) # 计算每个相位区间内的振幅均值 meanAmp = np.zeros(nbins) for i in range(nbins): indices = np.logical_and(phase &gt;= bins[i], phase &lt; bins[i+1]) meanAmp[i] = np.mean(amp[indices]) Pj = meanAmp/np.sum(meanAmp) H_Pj = -np.sum((Pj) * np.log(Pj)) KL = np.log(nbins) - H_Pj observed_mi = KL / np.log(nbins) return [observed_mi, meanAmp] 4、置换检验 定义：置换检验是一种统计方法，通过对数据进行随机重新排序或重组，产生一组随机分布，从而提供了对观察到的效应进行比较的基准。在计算CFC时，进行置换检验是为了评估观察到的耦合效应是否显著，即是否超出了随机预期。 计算步骤： 随机在幅值时间序列某数据点上将数据分为两部分，并将两部分时间序列的顺序颠倒，构造出置换幅值时间序列。 通过计算原始相位时间序列和置换幅值时间序列(反之亦然)之间的耦合值来构造洗牌耦合值。 这种生成替代数据的方法是最保守的，因为除了所研究的相位角和幅值之间的时间关系，它保留了脑电图数据的所有特征， 洗牌通常重复200-1000次。 将观察到的耦合值 CFCobservedCFC_{observed}CFCobserved​ 标准化为洗牌耦合值 CFCshuffledCFC_{shuffled}CFCshuffled​ 的分布，公式如下： CFCz=CFCobserved−μCFCshuffledσCFCshuffled\\begin{aligned} CFC_{z} = \\frac{CFC_{observed} - \\mu CFC_{shuffled} }{\\sigma CFC_{shuffled}} \\end{aligned} CFCz​=σCFCshuffled​CFCobserved​−μCFCshuffled​​​ 其中CFCCFCCFC为耦合值，$ \\mu $ 为 CFCshuffledCFC_{shuffled}CFCshuffled​ 均值，$\\sigma $ 为 CFCshuffledCFC_{shuffled}CFCshuffled​ 标准差。只有当 CFCobservedCFC_{observed}CFCobserved​ 大于95%的CFCshuffledCFC_{shuffled}CFCshuffled​时，才被定义为显著。因为z值等于1.64对应的p值为5%，所以当CFCzCFC_{z}CFCz​的值大于1.64 才被定义为显著。 python代码实现 123456789101112131415161718192021npnts = len(eeg)n_iter = 1000PLV_shuffled = np.zeros(n_iter)MVL_shuffled = np.zeros(n_iter)MI_shuffled = np.zeros(n_iter)for ni in range(n_iter): cutpoint = random.randrange(np.round(npnts/10), np.round(npnts*.9)) new_amp = np.concatenate((amp[cutpoint:] , amp[:cutpoint])) PLV_shuffled[ni] = PLV_CFC_WSH(phase, new_amp) MVL_shuffled[ni] = MVL_CFC_WSH(phase, new_amp) [MI, meanAmp] = MI_CFC_WSH(phase, new_amp, n_hist_bins) MI_shuffled[ni] = MI PLV_CFCz = (PLV_observed - np.mean(PLV_shuffled))/np.std(PLV_shuffled)MVL_CFCz = (MVL_observed- np.mean(MVL_shuffled))/np.std(MVL_shuffled)MI_CFCz = (MI_observed - np.mean(MI_shuffled))/np.std(MI_shuffled)print(&#x27;PLV_CFCz: &#x27;,PLV_CFCz)print(&#x27;MVL_CFCz: &#x27;,MVL_CFCz)print(&#x27;MI_CFCz: &#x27;,MI_CFCz) 5、实例分析 5.1 模拟信号的CFC 构建耦合信号 12345678910111213141516171819fs = 1000 # sampling frequency (samples per second/Hz) dt = 1/fs # seconds per sample stopTime = 5 # length of signal in seconds t = np.arange(0, stopTime-dt, dt).T # time vector in seconds stopTime_plot = 2 #limit time axis for improved visualization # 生成调制后的信号f_P = 4 # 低频相位f_A = 32 # 高频幅度f_AM = 0.5 # f_AM表示振幅调制的频率Afp = 1 # AfP是固定的标量，决定SO（慢波）的峰值振幅、K = 2 # K是固定的标量，决定FO（快波）的峰值振幅、beta = 0.3Xf_P = Afp * np.sin(2 * np.pi * f_P * t) # 慢波（低频相位）Afa = K * beta * np.sin(2 * np.pi * f_AM * t) Xf_A = Afa * np.sin(2 * np.pi * f_A * t) # 快波（高频振幅）signal = Xf_A + Xf_P 计算CFC 12345678910111213141516171819202122232425262728293031323334phasefilt = filterFGx(signal, fs, f_P, 0.5)phase = np.angle(hilbert(phasefilt))ampfilt = filterFGx(signal, fs, f_A, 20)amp = np.abs(hilbert(ampfilt))**2# 计算观测CFCPLV_observed = PLV_CFC_WSH(phase, amp)MVL_observed = MVL_CFC_WSH(phase, amp)n_hist_bins = 18[MI_observed, meanAmp] = MI_CFC_WSH(phase, amp, n_hist_bins)# 置换检验，计算洗牌CFCnpnts = len(signal)n_iter = 1000PLV_shuffled = np.zeros(n_iter)MVL_shuffled = np.zeros(n_iter)MI_shuffled = np.zeros(n_iter)for ni in range(n_iter): cutpoint = random.randrange(np.round(npnts/10), np.round(npnts*.9)) new_amp = np.concatenate((amp[cutpoint:] , amp[:cutpoint])) PLV_shuffled[ni] = PLV_CFC_WSH(phase, new_amp) MVL_shuffled[ni] = MVL_CFC_WSH(phase, new_amp) [MI, meanAmp] = MI_CFC_WSH(phase, new_amp, n_hist_bins) MI_shuffled[ni] = MI PLV_CFCz = (PLV_observed - np.mean(PLV_shuffled))/np.std(PLV_shuffled)MVL_CFCz = (MVL_observed- np.mean(MVL_shuffled))/np.std(MVL_shuffled)MI_CFCz = (MI_observed - np.mean(MI_shuffled))/np.std(MI_shuffled)print(&#x27;PLV_CFCz: &#x27;,PLV_CFCz)print(&#x27;MVL_CFCz: &#x27;,MVL_CFCz)print(&#x27;MI_CFCz: &#x27;,MI_CFCz) 5.2 EEG信号的CFC 加载EEG信号 123456789data = scipy.io.loadmat(&#x27;accumbens_eeg.mat&#x27;)srate = 1000npnts = len(data)eeg = data[&#x27;eeg&#x27;].reshape(-1)fig = plt.figure(figsize=(10, 4),dpi=600)ax1 = fig.add_subplot(1, 1, 1) # 子图1ax1.plot(eeg, label=&#x27;eeg_data&#x27;)ax1.legend()plt.show() 计算CFC 1234567891011121314151617181920212223242526272829303132333435# define frequencies for phase and for amplitudephas_freqs = np.arange(5, 20, 2)ampl_freqs = np.arange(30, 150, 5)# number of iterations used for permutation testingn_iter = 500# initialize output phase-amplitude matrixphaseamp = np.zeros([len(phas_freqs),len(ampl_freqs)])# loop over frequencies for phasefor lower_fi in range(len(phas_freqs)): # get phase values phasefilt = filterFGx(eeg, srate, phas_freqs[lower_fi], phas_freqs[lower_fi]*.4) phase = np.angle(hilbert(phasefilt)) # phase = angle(hilbert(phasefilt)) for upper_fi in range(len(ampl_freqs)): ampfilt = filterFGx(eeg, srate, ampl_freqs[upper_fi], ampl_freqs[upper_fi]*.78) amplit = np.abs(hilbert(ampfilt))**2 # calculate observed modulation index(MVL) [modidx, _] = MI_CFC_WSH(phase, amplit, 30) # now use permutation testing to get Z-value bm = np.zeros(n_iter) for bi in range (n_iter): cutpoint = random.randrange(np.round(npnts/10), np.round(npnts*.9)) new_amp = np.concatenate((amplit[cutpoint:] , amplit[:cutpoint])) [mi, _] = MI_CFC_WSH(phase, new_amp, 30) bm[bi] = mi # the value we use is the normalized distance away from the mean of # boot-strapped values phaseamp[lower_fi, upper_fi] = (modidx - np.mean(bm)) / np.std(bm) 可视化 1234fig, ax = plt.subplots()CFC_WSH = ax.contourf(phas_freqs, ampl_freqs, phaseamp.T)cbar = fig.colorbar(CFC_WSH)plt.show() 参考文献 [1] Li, C., et al., 2021. High-frequency hubs of the ictal cross-frequency coupling network predict surgical outcome in epilepsy patients. IEEE Transactions on Neural Systems and Rehabilitation Engineering, 29, pp.1290-1299. (2区) [2] Salimpour, Y. and Anderson, W.S., 2019. Cross-frequency coupling based neuromodulation for treating neurological disorders. Frontiers in neuroscience, 13, p.125. (3区) [3] Musaeus, C.S., et al., 2020. Electroencephalographic cross-frequency coupling as a sign of disease progression in patients with mild cognitive impairment: a pilot study. Frontiers in neuroscience, 14, p.790. (3区) [4] Zhang, W., et al., 2023. Altered fronto-central theta-gamma coupling in major depressive disorder during auditory steady-state responses. Clinical Neurophysiology, 146, pp.65-76. (3区) [5] Hülsemann, Mareike J., Ewald Naumann and Björn Rasch. 《Quantification of Phase-Amplitude Coupling in Neuronal Oscillations: Comparison of Phase-Locking Value, Mean Vector Length, Modulation Index, and Generalized-Linear-Modeling-Cross-Frequency-Coupling》. Frontiers in Neuroscience (2019). (3区)","categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"}],"tags":[{"name":"CFC","slug":"CFC","permalink":"https://weisihong9.github.io/tags/CFC/"}]},{"title":"EEG_TopoMap","slug":"EEG_TopoMap","date":"2023-07-02T16:00:00.000Z","updated":"2023-07-05T05:08:47.908Z","comments":true,"path":"2023/07/03/EEG_TopoMap/","link":"","permalink":"https://weisihong9.github.io/2023/07/03/EEG_TopoMap/","excerpt":"","text":"目的：利用MNE实现自定义矩阵大脑拓扑图的绘制 0、加载python库 123456import numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport mne%matplotlib qt 1、获取可用的电极布局系统 在使用MNE进行EEG信号的可视化操作时，往往需要导入对应电极的位置信息，MNE中有内置的常见电极布局系统，通过调用下面指令进行导入： 123456789101112131415161718192021222324252627282930mne.channels.get_builtin_montages()# output:[&#x27;standard_1005&#x27;, &#x27;standard_1020&#x27;, &#x27;standard_alphabetic&#x27;, &#x27;standard_postfixed&#x27;, &#x27;standard_prefixed&#x27;, &#x27;standard_primed&#x27;, &#x27;biosemi16&#x27;, &#x27;biosemi32&#x27;, &#x27;biosemi64&#x27;, &#x27;biosemi128&#x27;, &#x27;biosemi160&#x27;, &#x27;biosemi256&#x27;, &#x27;easycap-M1&#x27;, &#x27;easycap-M10&#x27;, &#x27;EGI_256&#x27;, &#x27;GSN-HydroCel-32&#x27;, &#x27;GSN-HydroCel-64_1.0&#x27;, &#x27;GSN-HydroCel-65_1.0&#x27;, &#x27;GSN-HydroCel-128&#x27;, &#x27;GSN-HydroCel-129&#x27;, &#x27;GSN-HydroCel-256&#x27;, &#x27;GSN-HydroCel-257&#x27;, &#x27;mgh60&#x27;, &#x27;mgh70&#x27;, &#x27;artinis-octamon&#x27;, &#x27;artinis-brite23&#x27;, &#x27;brainproducts-RNP-BA-128&#x27;] 从上面的输出可以看出，MNE中共有27个可用的电极布局系统，具体选择哪一个要看你采集数据时使用的脑电帽电极布局系统是哪个。 2、利用MNE自带的电极布局系统对矩阵进行通道定位 2.1 加载脑地形图位置坐标并可视化 123int32_montage = mne.channels.make_standard_montage(&#x27;biosemi32&#x27;)int32_montage.plot()plt.show() 2.2 构建自定义32导联的字典，导联名称与导联权重一一对应 1weight = &#123;&#x27;Fp1&#x27;: 0.31, &#x27;AF3&#x27;: -0.26, &#x27;F7&#x27;: 1.22, &#x27;F3&#x27;: 0.99, &#x27;Fz&#x27;: 0.71, &#x27;FC5&#x27;: 0.55, &#x27;FC1&#x27;: -1.19, &#x27;T7&#x27;: 0.61, &#x27;C3&#x27;: -0.80, &#x27;Cz&#x27;: 2.36, &#x27;CP5&#x27;: -0.74, &#x27;CP1&#x27;: 0.72, &#x27;P7&#x27;: 0.93, &#x27;P3&#x27;: 0.38, &#x27;Pz&#x27;: 1.07, &#x27;PO3&#x27;: -1.46, &#x27;O1&#x27;: -0.12, &#x27;Oz&#x27;: 1.074, &#x27;Fp2&#x27;: 1.04, &#x27;AF4&#x27;: -0.065, &#x27;F4&#x27;: -0.52, &#x27;F8&#x27;: 0.37, &#x27;FC2&#x27;: 1.30, &#x27;FC6&#x27;: 0.94, &#x27;C4&#x27;: -1.11, &#x27;T8&#x27;: -0.16, &#x27;CP2&#x27;: 1.82, &#x27;CP6&#x27;: 0.41, &#x27;P4&#x27;: 0.46, &#x27;P8&#x27;: 0.99, &#x27;PO4&#x27;:0.15, &#x27;O2&#x27;:0.23&#125; 2.3 根据脑地形图导联顺序重构自定义矩阵（*注意） 1234567891011# 查看脑地形图矩阵导联位置sensor_data_32 = int32_montage.get_positions()[&#x27;ch_pos&#x27;]sensor_dataframe_32 = pd.DataFrame(sensor_data_32).TchLa_index = sensor_dataframe_32.index.valuesprint(chLa_index)# 重构自定义矩阵顺序reWeight = []for key in chLa_index: val = weight[key] reWeight.append(val) 2.4 TopoMap可视化 2.4.1 创建info 12345info = mne.create_info( ch_names = chLa_index, ch_types = [&#x27;eeg&#x27;]*32, # 通道个数 sfreq = 1000) # 采样频率info.set_montage(int32_montage) 2.4.2 可视化 1234567im, cn = mne.viz.plot_topomap(reWeight, info, names = chLa_index.tolist(), # vlim=(-2, 2) )plt.colorbar(im)plt.show() 3、自定义电极布局文件对矩阵进行通道定位 假设我有一个64导联的帽子，根据实验需求，实验过程中我只选择中央区和顶叶区域的电极。 那么我们该如何根据自己选择的导联制定通道定位模版呢？ 这里有两种方法： 第一种：自定义新的电极布局文件，文件只包含实验选择的导联。这个方法的目的是教会你如何制作自己的电极布局文件，实际绘制时建议选择第二种方法。 第二种：使用原来的电极布局文件，先对矩阵进行归一化，后将未被选择的导联值置为0 4、第一种方法 4.1 下载标准的64通道电极布局系统坐标 12345# 读取MNE中biosemi64电极位置信息biosemi_montage = mne.channels.make_standard_montage(&#x27;biosemi64&#x27;)sensor_data_64 = biosemi_montage.get_positions()[&#x27;ch_pos&#x27;]sensor_dataframe_64 = pd.DataFrame(sensor_data_64).Tsensor_dataframe_64.to_excel(&#x27;sensor_dataframe_64.xlsx&#x27;) 4.2 根据下载文件，选择实验选取的电极坐标，保存为excel格式 1# 模仿下载的电极布局excel，自定义电极布局文件 4.3 加载自定义的excel文件，制作自己的montage 1234567myStardart = pd.read_excel(&#x27;mySensor_dataframe.xlsx&#x27;, index_col=0) # 读取自己的电极定位文件ch_names = np.array(myStardart.index) # 电极名称position = np.array(myStardart) # 电极坐标位置sensorPosition = dict(zip(ch_names, position)) # 制定为字典的形式myMontage = mne.channels.make_dig_montage(ch_pos=sensorPosition)myMontage.plot()plt.show() 4.4 自定义导联权重字典 1234myWeight = &#123;&#x27;C1&#x27;: 0.31, &#x27;C3&#x27;: 1.22, &#x27;P6&#x27;: 0.71, &#x27;P4&#x27;: 0.55,&#x27;P2&#x27;: -1.19, &#x27;CP5&#x27;: 0.61, &#x27;CP3&#x27;: -0.80, &#x27;CP1&#x27;: 2.36, &#x27;P1&#x27;: -0.74, &#x27;P3&#x27;: 0.72,&#x27;P5&#x27;: 0.93, &#x27;Pz&#x27;: -1.46, &#x27;CPz&#x27;: -0.12, &#x27;Cz&#x27;: 1.074,&#x27;C5&#x27;:2.34,&#x27;C2&#x27;: 1.04, &#x27;C4&#x27;: -0.065, &#x27;C6&#x27;: -0.52, &#x27;CP2&#x27;: 0.37, &#x27;CP4&#x27;: 1.30, &#x27;CP6&#x27;: 0.94&#125; 4.5 根据脑地形图导联顺序重构自定义矩阵（*注意） 123456789# 查看脑地形图矩阵导联位置my_chLa_index = ch_names.tolist()print(&#x27;脑地形图矩阵导联顺序:&#x27;,my_chLa_index)# 重构自定义矩阵顺序reMyWeight = []for key in my_chLa_index: val = myWeight[key] reMyWeight.append(val) 4.6 TopoMap可视化 4.6.1 创建info 12345myinfo = mne.create_info( ch_names = my_chLa_index, ch_types = [&#x27;eeg&#x27;]*21, # 通道个数 sfreq = 1000) # 采样频率myinfo.set_montage(myMontage) 4.6.2 可视化 12345678im, cn = mne.viz.plot_topomap(reMyWeight, myinfo, names = my_chLa_index, # vlim=(-2, 2) )plt.colorbar(im)plt.title(&#x27;My Montage&#x27;)plt.show() 5、第二种方法 5.1 读取标准的64通道电极布局系统坐标 1234567# 读取MNE中biosemi64电极位置信息biosemi_montage = mne.channels.make_standard_montage(&#x27;biosemi64&#x27;)sensor_data_64 = biosemi_montage.get_positions()[&#x27;ch_pos&#x27;]sensor_dataframe_64 = pd.DataFrame(sensor_data_64).TchLa_index_64 = sensor_dataframe_64.index.valuesbiosemi_montage.plot()plt.show() 5.2 构建自定义部分导联字典 1234myWeight = &#123;&#x27;C1&#x27;: 0.31, &#x27;C3&#x27;: 1.22, &#x27;P6&#x27;: 0.71, &#x27;P4&#x27;: 0.55,&#x27;P2&#x27;: -1.19, &#x27;CP5&#x27;: 0.61, &#x27;CP3&#x27;: -0.80, &#x27;CP1&#x27;: 2.36, &#x27;P1&#x27;: -0.74, &#x27;P3&#x27;: 0.72,&#x27;P5&#x27;: 0.93, &#x27;Pz&#x27;: -1.46, &#x27;CPz&#x27;: -0.12, &#x27;Cz&#x27;: 1.074,&#x27;C5&#x27;:2.34,&#x27;C2&#x27;: 1.04, &#x27;C4&#x27;: -0.065, &#x27;C6&#x27;: -0.52, &#x27;CP2&#x27;: 0.37, &#x27;CP4&#x27;: 1.30, &#x27;CP6&#x27;: 0.94&#125; 5.3 对字典的值进行归一化 123456789101112norMyWeiht = myWeight.copy()# Step 1: 获取需要归一化的值values = [v for v in norMyWeiht.values()]# Step 2: 找到最小值和最大值min_value = min(values)max_value = max(values)# Step 3: 对值进行归一化计算for key, value in norMyWeiht.items(): normalized_value = (value - min_value) / (max_value - min_value) norMyWeiht[key] = normalized_value 5.4 根据脑地形图导联顺序重构标准化后的矩阵，将未被选择的导联值置为0 123456789print(&#x27;脑地形图矩阵导联顺序:&#x27;,chLa_index_64)# 重构自定义矩阵顺序reNorMyWeight = []for key in chLa_index_64: if key in norMyWeiht: val = norMyWeiht[key] reNorMyWeight.append(val) else: reNorMyWeight.append(0) 5.5 TopoMap可视化 5.5.1 创建info 12345info = mne.create_info( ch_names = chLa_index_64.tolist(), ch_types = [&#x27;eeg&#x27;]*len(reNorMyWeight), # 通道个数 sfreq = 1000) # 采样频率info.set_montage(biosemi_montage) 5.5.2 可视化 123456789im, cn = mne.viz.plot_topomap(reNorMyWeight, info, names = chLa_index_64, cmap = &#x27;jet&#x27; # vlim=(-2, 2) )plt.colorbar(im)plt.title(&#x27;My Montage&#x27;)plt.show() 6、代码下载 https://github.com/weisihong9/EEG_TopoMap.git","categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"},{"name":"BEAM","slug":"EEG/BEAM","permalink":"https://weisihong9.github.io/categories/EEG/BEAM/"}],"tags":[{"name":"BEAM","slug":"BEAM","permalink":"https://weisihong9.github.io/tags/BEAM/"}]},{"title":"Using_Markdown_writing","slug":"Using_Markdown_writing","date":"2023-05-21T08:54:43.000Z","updated":"2024-05-15T02:29:43.598Z","comments":true,"path":"2023/05/21/Using_Markdown_writing/","link":"","permalink":"https://weisihong9.github.io/2023/05/21/Using_Markdown_writing/","excerpt":"","text":"自动添加目录 在前头添加：toc: true 自动编号很烦，还不知道咋解决 这是一级标题 下面开始说明如何使用markdown进行写作 这是二级标题 这是正文 换一行？ （在上一行后面按两次空格，再回车就是换一行） 换一段（按两次换行就是换一段） 0 各种符号 横线隔开 a b [X] c [X] d 标注 1 强调 加粗了: 前后各加两个*号 斜体：前后各加一个星号 2 列表 自动编号：数字 + 点 + 空格即可 来一个二级标题 按一下回车，再tab就行 再来一个三级标题 按回车，再按tab 继续回车，再tab 3 插入图片：图床上传图片 把图片先上传到自己的图床，然后复制生成的图片链接。 格式为：!+[图片名字]+(http:\\……png) 图片注释 或者： 4 数学公式 lim⁡x→∞sin(x)x=1\\lim_{x \\to \\infin}\\frac{sin(x)}{x}=1 x→∞lim​xsin(x)​=1 在一段文字中插入公式: lim⁡x→∞f(x)\\lim_{x \\to \\infin}f(x)limx→∞​f(x), command + m 快捷键连按两次就可以生成4个美元符号然后输入公式 5 表格 EMD HHT HHSA 1 2 3 左对其 居中对齐 右对齐 调整编辑部分表格格式快捷键： 先选中表格内容，然后：Alt（fn+option） + shift + f 6 插入链接 复制网址，然后选中要给超链接的文字，直接：command + v 就行 这是一个laTex的链接 7 code 英文的三个小点：1左边的那个键 12# ``` javascript# ``` 1234import numpy as npfrom PyEMD import EMDimport matplotlib.pyplot as plt 8 导航 9 将md文件导出为pdf 首先下载这个插件：Markdown Preview Enhanced 然后 command + shift + v 打开 Preview **.md 界面 最后在 Preview **.md 界面，右键，然后选中：Chrome(Puppeteer) --&gt; PDF 即可 10 这是该md文件的下载链接！ 下载","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://weisihong9.github.io/tags/Markdown/"}]},{"title":"EMD","slug":"EMD","date":"2023-05-20T16:58:43.000Z","updated":"2023-05-21T15:59:47.986Z","comments":true,"path":"2023/05/21/EMD/","link":"","permalink":"https://weisihong9.github.io/2023/05/21/EMD/","excerpt":"","text":"目的：利用python自带的 pyEMD 实现 经验模态分解（EMD） 1 加载python库 123import numpy as npfrom PyEMD import EMDimport matplotlib.pyplot as plt 2 EMD分解 12345678910111213141516171819202122# 生成示例信号t = np.linspace(0, 1, 1000)signal = np.sin(5 * 2 * np.pi * t) + np.sin(10 * 2 * np.pi * t)# 创建EMD对象emd = EMD()# 执行EMD分解IMFs = emd(signal)# 绘制分解后的IMFsplt.figure(figsize=(10, 6),dpi=600)plt.subplot(len(IMFs) + 1, 1, 1)plt.plot(t, signal, &#x27;b&#x27;)plt.title(&#x27;Original Signal&#x27;)for i, IMF in enumerate(IMFs): plt.subplot(len(IMFs) + 1, 1, i + 2) plt.plot(t, IMF, &#x27;r&#x27;) plt.title(&#x27;IMF %d&#x27; % (i + 1))plt.tight_layout()plt.show() 3 结束","categories":[{"name":"Signal processing","slug":"Signal-processing","permalink":"https://weisihong9.github.io/categories/Signal-processing/"},{"name":"EMD","slug":"Signal-processing/EMD","permalink":"https://weisihong9.github.io/categories/Signal-processing/EMD/"}],"tags":[{"name":"EMD","slug":"EMD","permalink":"https://weisihong9.github.io/tags/EMD/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-05-20T10:35:24.631Z","updated":"2023-05-20T10:35:24.632Z","comments":true,"path":"2023/05/20/hello-world/","link":"","permalink":"https://weisihong9.github.io/2023/05/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"},{"name":"ERSP","slug":"EEG/ERSP","permalink":"https://weisihong9.github.io/categories/EEG/ERSP/"},{"name":"FBN","slug":"EEG/FBN","permalink":"https://weisihong9.github.io/categories/EEG/FBN/"},{"name":"Graph","slug":"Graph","permalink":"https://weisihong9.github.io/categories/Graph/"},{"name":"EEG","slug":"Graph/EEG","permalink":"https://weisihong9.github.io/categories/Graph/EEG/"},{"name":"BEAM","slug":"EEG/BEAM","permalink":"https://weisihong9.github.io/categories/EEG/BEAM/"},{"name":"Signal processing","slug":"Signal-processing","permalink":"https://weisihong9.github.io/categories/Signal-processing/"},{"name":"EMD","slug":"Signal-processing/EMD","permalink":"https://weisihong9.github.io/categories/Signal-processing/EMD/"}],"tags":[{"name":"ERSP","slug":"ERSP","permalink":"https://weisihong9.github.io/tags/ERSP/"},{"name":"FBN","slug":"FBN","permalink":"https://weisihong9.github.io/tags/FBN/"},{"name":"BEAM","slug":"BEAM","permalink":"https://weisihong9.github.io/tags/BEAM/"},{"name":"CFC","slug":"CFC","permalink":"https://weisihong9.github.io/tags/CFC/"},{"name":"Markdown","slug":"Markdown","permalink":"https://weisihong9.github.io/tags/Markdown/"},{"name":"EMD","slug":"EMD","permalink":"https://weisihong9.github.io/tags/EMD/"}]}