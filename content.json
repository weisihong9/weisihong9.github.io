{"meta":{"title":"WeiSH's BLOG","subtitle":"MaTRix","description":"","author":"weisihong","url":"https://weisihong9.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-05-21T15:33:58.437Z","updated":"2023-05-20T13:09:31.547Z","comments":false,"path":"about/index.html","permalink":"https://weisihong9.github.io/about/index.html","excerpt":"","text":"Weisihong：生命科学与技术学院，健康与康复科学研究所的研究生 研究方向：信号预处理、EEG与fNIRS多模态融合、时频分析、脑网络功能连接算法、机器学习、统计分析"},{"title":"留言","date":"2023-05-21T15:13:23.000Z","updated":"2023-05-21T15:34:41.059Z","comments":true,"path":"guestbook/index.html","permalink":"https://weisihong9.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-05-21T15:34:11.984Z","updated":"2023-05-21T15:34:11.984Z","comments":false,"path":"categories/index.html","permalink":"https://weisihong9.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目仓库","date":"2023-05-21T15:34:31.651Z","updated":"2023-05-21T15:34:31.651Z","comments":false,"path":"repository/index.html","permalink":"https://weisihong9.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-21T15:34:49.343Z","updated":"2023-05-21T15:34:49.343Z","comments":false,"path":"tags/index.html","permalink":"https://weisihong9.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CrossFrequencyCoupling","slug":"CrossFrequencyCoupling","date":"2023-07-05T05:00:49.000Z","updated":"2023-07-06T08:00:48.066Z","comments":true,"path":"2023/07/05/CrossFrequencyCoupling/","link":"","permalink":"https://weisihong9.github.io/2023/07/05/CrossFrequencyCoupling/","excerpt":"","text":"目的：介绍跨频耦合的背景及常用的计算方法 1、背景 神经科学的核心问题之一是神经活动如何在不同的空间和时间尺度上协调。 跨频率耦合(Cross-frequency coupling, CFC) 已被提出在时间和空间尺度上协调神经动力学。 时间尺度：神经振荡之间的相幅耦合。例如，低频振荡的相位可以影响高频振荡的振幅，从而调节神经活动的时序，实现信息处理和集成。 空间尺度：神经振荡之间的空间耦合。例如，不同频率范围内的神经振荡可以在不同脑区之间相互调节，形成神经网络，实现信息的传递和整合。 EEG信号的CFC是指不同频率范围内的神经振荡之间存在相互调节和交互作用的现象。换句话说，CFC实际上是不同频带EEG的幅度/频率/相位之间的关系。常见的耦合关系如下：【慢震荡（Slow Oscillation，SO）；快震荡（ Fast Oscillation，FO ）】 相位-幅度耦合(phase-amplitude coupling，PAC)：SO的相位与FO幅度之间的耦合，也称为“嵌套”。目前研究比较多的是θ - γ和α - γ之间的PAC。 相位-频率耦合(phase- frequency coupling，PFC)：SO的相位和FO的频率之间的耦合。 相位-相位耦合(phase-phase coupling，PPC)：SO和FO相位之间的耦合。 2、CFC在神经疾病中的应用 跨频耦合作为一种神经机制，在多种神经疾病中都得到了广泛研究： 癫痫：研究表明[1]， 跨频频率耦合是定位癫痫组织的有用生物标志物。 帕金森病：研究表明[2]，theta-gamma跨频耦合可以作为帕金森疾病的生物标志，并有助于对帕金森疾病的早期诊断和治疗进行监测。 精神分裂症：研究表明[3]， theta-gamma跨频耦合减弱与认知障碍症状的严重程度有关。 抑郁症：研究表明[4]，抑郁症患者与健康对照组相比，前额叶皮层的theta-gamma跨频耦合存在显著差异。 3、CFC常用计算方法 [5] 锁相值（phase-locking value，PLV） 平均向量长度（mean vector length，MVL） 调制指数（modulation index，MI） 3.1 锁相值（phase-locking value，PLV） 定义：PLV通过比较两个信号的相位差来评估它们之间的同步性。如果两个信号存在相位-幅度耦合，那么高频时间序列的振幅将在低频振荡。 计算步骤 计算公式 PLV=∣∑t=1nei(θlt−θut)n∣PLV=|\\frac{ {\\sum_{t=1}^{n}{e^{i(\\theta _{lt}-\\theta _{ut})} } } }{n}| PLV=∣n∑t=1n​ei(θlt​−θut​)​∣ 其中 n：数据点总数 t：时间数据点 θlt：t时刻的低频相位角 θut：希尔伯特变换后的高频振幅时间序列在t时刻的相位角 优点和缺点： 优点：受噪声影响小。 缺点：希尔伯特转换后的振幅时间序列不一定是窄带振荡。 python代码实现： 1234567# 利用PLV计算相幅耦合def PLV_CFC_WSH(phase, amp): # phase：低频信号的相位 # amp：高频信号的振幅 amp_phi = np.angle(hilbert(amp)) # 高频信号振幅的相位 observed_plv = np.abs(np.sum(np.exp(1j*(phase - amp_phi)))/len(phase)) return observed_plv 3.2 平均向量长度（mean vector length，MVL） 定义：MVL是一个向量集合中各个向量长度的平均值，它提供了对向量集合整体大小或幅度的一种度量。在CFC的计算中，将对应时刻的低频信号的相位角作为向量的方向，高频信号的振幅作为向量的幅度。 计算步骤： 计算公式： MVL=∣∑t=1nateiθtn∣MVL=\\left | \\frac{ {\\textstyle \\sum_{t=1}^{n}{a_{t} e^{i\\theta _{t}} } } }{n}\\right | MVL=∣∣∣∣∣​n∑t=1n​at​eiθt​​∣∣∣∣∣​ 其中: n：数据点总数 t：时间数据点 at：高频振幅时间序列在t时刻的幅值 θt：低频相位时间序列在t时刻的相位角 优点和缺点： 优点：对于长数据段，高采样率，高信噪比的信号，建议使用MVL。 缺点： MVL的计算受到频率振幅的整体幅度影响。如果某个频率的振幅较大，那么它将在计算MVL时有更大的权重。这可能会导致对整个向量集合大小或幅度的评估存在一定的偏差。 振幅异常值可能会强烈影响平均向量长度。 不同向量之间的相位角差异可能会影响平均向量长度的计算结果。 python代码实现： 1234567# 利用MVL计算相幅耦合def MVL_CFC_WSH(phase, amp): # phase：低频信号的相位 # amp：高频信号的振幅 amp_nor = (amp - np.min(amp)) / (np.max(amp) - np.min(amp)) # 振幅归一化 observed_mvl = np.abs(np.mean(amp_nor * np.exp(1j*phase))) return observed_mvl 3.3 调制指数（modulation index，MI） 定义：MI通过计算幅度和相位的熵来估计幅度调制指数。 计算步骤： 计算公式： p(j)=aˉ∑k=1Naˉk\\begin{aligned}p(j)=\\frac{\\bar{a} }{ {\\textstyle \\sum_{k=1}^{N}} \\bar{a} _{k}} \\end{aligned} p(j)=∑k=1N​aˉk​aˉ​​ ā为单个bin的平均振幅，k为bins的运行指数，N为bins的总数；p是一个有N个值的向量；H(p)为香农熵。 H(p)=−∑j=1Np(j)logp(j)KL(U,X)=logN−H(p)MI=KL(U,X)logN\\begin{aligned} H(p)=- {\\textstyle \\sum_{j=1}^{N}p(j)logp(j)}\\\\ KL(U,X)=logN-H(p)\\\\ MI=\\frac{KL(U,X)}{logN} \\end{aligned} H(p)=−∑j=1N​p(j)logp(j)KL(U,X)=logN−H(p)MI=logNKL(U,X)​​ U为均匀分布，X为数据分布。 KL(U, K): KL散度描述了用均匀分布U来估计数据的真实分布X的编码损失。 优点和缺点： 优点： 归一化熵是一种常用的信号复杂性度量，可以反映信号的不确定性和信息丰富度。 对于更短的数据，更低的采样率，更高噪声的数据，建议使用MI。 MI是使用最多的CFC方法。 缺点： 4. 依赖于特定的熵测量方法； 5. 对数据预处理的要求较高； python代码实现： 12345678910111213141516# 利用MI计算相幅耦合def MI_CFC_WSH(phase, amp, nbins): # phase：低频信号的相位 # amp：高频信号的振幅 # nbins：划分的箱子数 bins = np.linspace(-np.pi, np.pi, nbins+1) # 计算每个相位区间内的振幅均值 meanAmp = np.zeros(nbins) for i in range(nbins): indices = np.logical_and(phase &gt;= bins[i], phase &lt; bins[i+1]) meanAmp[i] = np.mean(amp[indices]) Pj = meanAmp/np.sum(meanAmp) H_Pj = -np.sum((Pj) * np.log(Pj)) KL = np.log(nbins) - H_Pj observed_mi = KL / np.log(nbins) return [observed_mi, meanAmp] 4、置换检验 定义：置换检验是一种统计方法，通过对数据进行随机重新排序或重组，产生一组随机分布，从而提供了对观察到的效应进行比较的基准。在计算CFC时，进行置换检验是为了评估观察到的耦合效应是否显著，即是否超出了随机预期。 计算步骤： 随机在幅值时间序列某数据点上将数据分为两部分，并将两部分时间序列的顺序颠倒，构造出置换幅值时间序列。 通过计算原始相位时间序列和置换幅值时间序列(反之亦然)之间的耦合值来构造洗牌耦合值。 这种生成替代数据的方法是最保守的，因为除了所研究的相位角和幅值之间的时间关系，它保留了脑电图数据的所有特征， 洗牌通常重复200-1000次。 将观察到的耦合值 CFCobservedCFC_{observed}CFCobserved​ 标准化为洗牌耦合值 CFCshuffledCFC_{shuffled}CFCshuffled​ 的分布，公式如下： CFCz=CFCobserved−μCFCshuffledσCFCshuffled\\begin{aligned} CFC_{z} = \\frac{CFC_{observed} - \\mu CFC_{shuffled} }{\\sigma CFC_{shuffled}} \\end{aligned} CFCz​=σCFCshuffled​CFCobserved​−μCFCshuffled​​​ 其中CFCCFCCFC为耦合值，$ \\mu $ 为 CFCshuffledCFC_{shuffled}CFCshuffled​ 均值，$\\sigma $ 为 CFCshuffledCFC_{shuffled}CFCshuffled​ 标准差。只有当 CFCobservedCFC_{observed}CFCobserved​ 大于95%的CFCshuffledCFC_{shuffled}CFCshuffled​时，才被定义为显著。因为z值等于1.64对应的p值为5%，所以当CFCzCFC_{z}CFCz​的值大于1.64 才被定义为显著。 python代码实现 123456789101112131415161718192021npnts = len(eeg)n_iter = 1000PLV_shuffled = np.zeros(n_iter)MVL_shuffled = np.zeros(n_iter)MI_shuffled = np.zeros(n_iter)for ni in range(n_iter): cutpoint = random.randrange(np.round(npnts/10), np.round(npnts*.9)) new_amp = np.concatenate((amp[cutpoint:] , amp[:cutpoint])) PLV_shuffled[ni] = PLV_CFC_WSH(phase, new_amp) MVL_shuffled[ni] = MVL_CFC_WSH(phase, new_amp) [MI, meanAmp] = MI_CFC_WSH(phase, new_amp, n_hist_bins) MI_shuffled[ni] = MI PLV_CFCz = (PLV_observed - np.mean(PLV_shuffled))/np.std(PLV_shuffled)MVL_CFCz = (MVL_observed- np.mean(MVL_shuffled))/np.std(MVL_shuffled)MI_CFCz = (MI_observed - np.mean(MI_shuffled))/np.std(MI_shuffled)print(&#x27;PLV_CFCz: &#x27;,PLV_CFCz)print(&#x27;MVL_CFCz: &#x27;,MVL_CFCz)print(&#x27;MI_CFCz: &#x27;,MI_CFCz) 5、实例分析 5.1 模拟信号的CFC 构建耦合信号 12345678910111213141516171819fs = 1000 # sampling frequency (samples per second/Hz) dt = 1/fs # seconds per sample stopTime = 5 # length of signal in seconds t = np.arange(0, stopTime-dt, dt).T # time vector in seconds stopTime_plot = 2 #limit time axis for improved visualization # 生成调制后的信号f_P = 4 # 低频相位f_A = 32 # 高频幅度f_AM = 0.5 # f_AM表示振幅调制的频率Afp = 1 # AfP是固定的标量，决定SO（慢波）的峰值振幅、K = 2 # K是固定的标量，决定FO（快波）的峰值振幅、beta = 0.3Xf_P = Afp * np.sin(2 * np.pi * f_P * t) # 慢波（低频相位）Afa = K * beta * np.sin(2 * np.pi * f_AM * t) Xf_A = Afa * np.sin(2 * np.pi * f_A * t) # 快波（高频振幅）signal = Xf_A + Xf_P 计算CFC 12345678910111213141516171819202122232425262728293031323334phasefilt = filterFGx(signal, fs, f_P, 0.5)phase = np.angle(hilbert(phasefilt))ampfilt = filterFGx(signal, fs, f_A, 20)amp = np.abs(hilbert(ampfilt))**2# 计算观测CFCPLV_observed = PLV_CFC_WSH(phase, amp)MVL_observed = MVL_CFC_WSH(phase, amp)n_hist_bins = 18[MI_observed, meanAmp] = MI_CFC_WSH(phase, amp, n_hist_bins)# 置换检验，计算洗牌CFCnpnts = len(signal)n_iter = 1000PLV_shuffled = np.zeros(n_iter)MVL_shuffled = np.zeros(n_iter)MI_shuffled = np.zeros(n_iter)for ni in range(n_iter): cutpoint = random.randrange(np.round(npnts/10), np.round(npnts*.9)) new_amp = np.concatenate((amp[cutpoint:] , amp[:cutpoint])) PLV_shuffled[ni] = PLV_CFC_WSH(phase, new_amp) MVL_shuffled[ni] = MVL_CFC_WSH(phase, new_amp) [MI, meanAmp] = MI_CFC_WSH(phase, new_amp, n_hist_bins) MI_shuffled[ni] = MI PLV_CFCz = (PLV_observed - np.mean(PLV_shuffled))/np.std(PLV_shuffled)MVL_CFCz = (MVL_observed- np.mean(MVL_shuffled))/np.std(MVL_shuffled)MI_CFCz = (MI_observed - np.mean(MI_shuffled))/np.std(MI_shuffled)print(&#x27;PLV_CFCz: &#x27;,PLV_CFCz)print(&#x27;MVL_CFCz: &#x27;,MVL_CFCz)print(&#x27;MI_CFCz: &#x27;,MI_CFCz) 5.2 EEG信号的CFC 加载EEG信号 123456789data = scipy.io.loadmat(&#x27;accumbens_eeg.mat&#x27;)srate = 1000npnts = len(data)eeg = data[&#x27;eeg&#x27;].reshape(-1)fig = plt.figure(figsize=(10, 4),dpi=600)ax1 = fig.add_subplot(1, 1, 1) # 子图1ax1.plot(eeg, label=&#x27;eeg_data&#x27;)ax1.legend()plt.show() 计算CFC 1234567891011121314151617181920212223242526272829303132333435# define frequencies for phase and for amplitudephas_freqs = np.arange(5, 20, 2)ampl_freqs = np.arange(30, 150, 5)# number of iterations used for permutation testingn_iter = 500# initialize output phase-amplitude matrixphaseamp = np.zeros([len(phas_freqs),len(ampl_freqs)])# loop over frequencies for phasefor lower_fi in range(len(phas_freqs)): # get phase values phasefilt = filterFGx(eeg, srate, phas_freqs[lower_fi], phas_freqs[lower_fi]*.4) phase = np.angle(hilbert(phasefilt)) # phase = angle(hilbert(phasefilt)) for upper_fi in range(len(ampl_freqs)): ampfilt = filterFGx(eeg, srate, ampl_freqs[upper_fi], ampl_freqs[upper_fi]*.78) amplit = np.abs(hilbert(ampfilt))**2 # calculate observed modulation index(MVL) [modidx, _] = MI_CFC_WSH(phase, amplit, 30) # now use permutation testing to get Z-value bm = np.zeros(n_iter) for bi in range (n_iter): cutpoint = random.randrange(np.round(npnts/10), np.round(npnts*.9)) new_amp = np.concatenate((amplit[cutpoint:] , amplit[:cutpoint])) [mi, _] = MI_CFC_WSH(phase, new_amp, 30) bm[bi] = mi # the value we use is the normalized distance away from the mean of # boot-strapped values phaseamp[lower_fi, upper_fi] = (modidx - np.mean(bm)) / np.std(bm) 可视化 1234fig, ax = plt.subplots()CFC_WSH = ax.contourf(phas_freqs, ampl_freqs, phaseamp.T)cbar = fig.colorbar(CFC_WSH)plt.show() 参考文献 [1] Li, C., et al., 2021. High-frequency hubs of the ictal cross-frequency coupling network predict surgical outcome in epilepsy patients. IEEE Transactions on Neural Systems and Rehabilitation Engineering, 29, pp.1290-1299. (2区) [2] Salimpour, Y. and Anderson, W.S., 2019. Cross-frequency coupling based neuromodulation for treating neurological disorders. Frontiers in neuroscience, 13, p.125. (3区) [3] Musaeus, C.S., et al., 2020. Electroencephalographic cross-frequency coupling as a sign of disease progression in patients with mild cognitive impairment: a pilot study. Frontiers in neuroscience, 14, p.790. (3区) [4] Zhang, W., et al., 2023. Altered fronto-central theta-gamma coupling in major depressive disorder during auditory steady-state responses. Clinical Neurophysiology, 146, pp.65-76. (3区) [5] Hülsemann, Mareike J., Ewald Naumann and Björn Rasch. 《Quantification of Phase-Amplitude Coupling in Neuronal Oscillations: Comparison of Phase-Locking Value, Mean Vector Length, Modulation Index, and Generalized-Linear-Modeling-Cross-Frequency-Coupling》. Frontiers in Neuroscience (2019). (3区)","categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"}],"tags":[{"name":"CFC","slug":"CFC","permalink":"https://weisihong9.github.io/tags/CFC/"}]},{"title":"EEG_TopoMap","slug":"EEG_TopoMap","date":"2023-07-02T16:00:00.000Z","updated":"2023-07-05T05:08:47.908Z","comments":true,"path":"2023/07/03/EEG_TopoMap/","link":"","permalink":"https://weisihong9.github.io/2023/07/03/EEG_TopoMap/","excerpt":"","text":"目的：利用MNE实现自定义矩阵大脑拓扑图的绘制 0、加载python库 123456import numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport mne%matplotlib qt 1、获取可用的电极布局系统 在使用MNE进行EEG信号的可视化操作时，往往需要导入对应电极的位置信息，MNE中有内置的常见电极布局系统，通过调用下面指令进行导入： 123456789101112131415161718192021222324252627282930mne.channels.get_builtin_montages()# output:[&#x27;standard_1005&#x27;, &#x27;standard_1020&#x27;, &#x27;standard_alphabetic&#x27;, &#x27;standard_postfixed&#x27;, &#x27;standard_prefixed&#x27;, &#x27;standard_primed&#x27;, &#x27;biosemi16&#x27;, &#x27;biosemi32&#x27;, &#x27;biosemi64&#x27;, &#x27;biosemi128&#x27;, &#x27;biosemi160&#x27;, &#x27;biosemi256&#x27;, &#x27;easycap-M1&#x27;, &#x27;easycap-M10&#x27;, &#x27;EGI_256&#x27;, &#x27;GSN-HydroCel-32&#x27;, &#x27;GSN-HydroCel-64_1.0&#x27;, &#x27;GSN-HydroCel-65_1.0&#x27;, &#x27;GSN-HydroCel-128&#x27;, &#x27;GSN-HydroCel-129&#x27;, &#x27;GSN-HydroCel-256&#x27;, &#x27;GSN-HydroCel-257&#x27;, &#x27;mgh60&#x27;, &#x27;mgh70&#x27;, &#x27;artinis-octamon&#x27;, &#x27;artinis-brite23&#x27;, &#x27;brainproducts-RNP-BA-128&#x27;] 从上面的输出可以看出，MNE中共有27个可用的电极布局系统，具体选择哪一个要看你采集数据时使用的脑电帽电极布局系统是哪个。 2、利用MNE自带的电极布局系统对矩阵进行通道定位 2.1 加载脑地形图位置坐标并可视化 123int32_montage = mne.channels.make_standard_montage(&#x27;biosemi32&#x27;)int32_montage.plot()plt.show() 2.2 构建自定义32导联的字典，导联名称与导联权重一一对应 1weight = &#123;&#x27;Fp1&#x27;: 0.31, &#x27;AF3&#x27;: -0.26, &#x27;F7&#x27;: 1.22, &#x27;F3&#x27;: 0.99, &#x27;Fz&#x27;: 0.71, &#x27;FC5&#x27;: 0.55, &#x27;FC1&#x27;: -1.19, &#x27;T7&#x27;: 0.61, &#x27;C3&#x27;: -0.80, &#x27;Cz&#x27;: 2.36, &#x27;CP5&#x27;: -0.74, &#x27;CP1&#x27;: 0.72, &#x27;P7&#x27;: 0.93, &#x27;P3&#x27;: 0.38, &#x27;Pz&#x27;: 1.07, &#x27;PO3&#x27;: -1.46, &#x27;O1&#x27;: -0.12, &#x27;Oz&#x27;: 1.074, &#x27;Fp2&#x27;: 1.04, &#x27;AF4&#x27;: -0.065, &#x27;F4&#x27;: -0.52, &#x27;F8&#x27;: 0.37, &#x27;FC2&#x27;: 1.30, &#x27;FC6&#x27;: 0.94, &#x27;C4&#x27;: -1.11, &#x27;T8&#x27;: -0.16, &#x27;CP2&#x27;: 1.82, &#x27;CP6&#x27;: 0.41, &#x27;P4&#x27;: 0.46, &#x27;P8&#x27;: 0.99, &#x27;PO4&#x27;:0.15, &#x27;O2&#x27;:0.23&#125; 2.3 根据脑地形图导联顺序重构自定义矩阵（*注意） 1234567891011# 查看脑地形图矩阵导联位置sensor_data_32 = int32_montage.get_positions()[&#x27;ch_pos&#x27;]sensor_dataframe_32 = pd.DataFrame(sensor_data_32).TchLa_index = sensor_dataframe_32.index.valuesprint(chLa_index)# 重构自定义矩阵顺序reWeight = []for key in chLa_index: val = weight[key] reWeight.append(val) 2.4 TopoMap可视化 2.4.1 创建info 12345info = mne.create_info( ch_names = chLa_index, ch_types = [&#x27;eeg&#x27;]*32, # 通道个数 sfreq = 1000) # 采样频率info.set_montage(int32_montage) 2.4.2 可视化 1234567im, cn = mne.viz.plot_topomap(reWeight, info, names = chLa_index.tolist(), # vlim=(-2, 2) )plt.colorbar(im)plt.show() 3、自定义电极布局文件对矩阵进行通道定位 假设我有一个64导联的帽子，根据实验需求，实验过程中我只选择中央区和顶叶区域的电极。 那么我们该如何根据自己选择的导联制定通道定位模版呢？ 这里有两种方法： 第一种：自定义新的电极布局文件，文件只包含实验选择的导联。这个方法的目的是教会你如何制作自己的电极布局文件，实际绘制时建议选择第二种方法。 第二种：使用原来的电极布局文件，先对矩阵进行归一化，后将未被选择的导联值置为0 4、第一种方法 4.1 下载标准的64通道电极布局系统坐标 12345# 读取MNE中biosemi64电极位置信息biosemi_montage = mne.channels.make_standard_montage(&#x27;biosemi64&#x27;)sensor_data_64 = biosemi_montage.get_positions()[&#x27;ch_pos&#x27;]sensor_dataframe_64 = pd.DataFrame(sensor_data_64).Tsensor_dataframe_64.to_excel(&#x27;sensor_dataframe_64.xlsx&#x27;) 4.2 根据下载文件，选择实验选取的电极坐标，保存为excel格式 1# 模仿下载的电极布局excel，自定义电极布局文件 4.3 加载自定义的excel文件，制作自己的montage 1234567myStardart = pd.read_excel(&#x27;mySensor_dataframe.xlsx&#x27;, index_col=0) # 读取自己的电极定位文件ch_names = np.array(myStardart.index) # 电极名称position = np.array(myStardart) # 电极坐标位置sensorPosition = dict(zip(ch_names, position)) # 制定为字典的形式myMontage = mne.channels.make_dig_montage(ch_pos=sensorPosition)myMontage.plot()plt.show() 4.4 自定义导联权重字典 1234myWeight = &#123;&#x27;C1&#x27;: 0.31, &#x27;C3&#x27;: 1.22, &#x27;P6&#x27;: 0.71, &#x27;P4&#x27;: 0.55,&#x27;P2&#x27;: -1.19, &#x27;CP5&#x27;: 0.61, &#x27;CP3&#x27;: -0.80, &#x27;CP1&#x27;: 2.36, &#x27;P1&#x27;: -0.74, &#x27;P3&#x27;: 0.72,&#x27;P5&#x27;: 0.93, &#x27;Pz&#x27;: -1.46, &#x27;CPz&#x27;: -0.12, &#x27;Cz&#x27;: 1.074,&#x27;C5&#x27;:2.34,&#x27;C2&#x27;: 1.04, &#x27;C4&#x27;: -0.065, &#x27;C6&#x27;: -0.52, &#x27;CP2&#x27;: 0.37, &#x27;CP4&#x27;: 1.30, &#x27;CP6&#x27;: 0.94&#125; 4.5 根据脑地形图导联顺序重构自定义矩阵（*注意） 123456789# 查看脑地形图矩阵导联位置my_chLa_index = ch_names.tolist()print(&#x27;脑地形图矩阵导联顺序:&#x27;,my_chLa_index)# 重构自定义矩阵顺序reMyWeight = []for key in my_chLa_index: val = myWeight[key] reMyWeight.append(val) 4.6 TopoMap可视化 4.6.1 创建info 12345myinfo = mne.create_info( ch_names = my_chLa_index, ch_types = [&#x27;eeg&#x27;]*21, # 通道个数 sfreq = 1000) # 采样频率myinfo.set_montage(myMontage) 4.6.2 可视化 12345678im, cn = mne.viz.plot_topomap(reMyWeight, myinfo, names = my_chLa_index, # vlim=(-2, 2) )plt.colorbar(im)plt.title(&#x27;My Montage&#x27;)plt.show() 5、第二种方法 5.1 读取标准的64通道电极布局系统坐标 1234567# 读取MNE中biosemi64电极位置信息biosemi_montage = mne.channels.make_standard_montage(&#x27;biosemi64&#x27;)sensor_data_64 = biosemi_montage.get_positions()[&#x27;ch_pos&#x27;]sensor_dataframe_64 = pd.DataFrame(sensor_data_64).TchLa_index_64 = sensor_dataframe_64.index.valuesbiosemi_montage.plot()plt.show() 5.2 构建自定义部分导联字典 1234myWeight = &#123;&#x27;C1&#x27;: 0.31, &#x27;C3&#x27;: 1.22, &#x27;P6&#x27;: 0.71, &#x27;P4&#x27;: 0.55,&#x27;P2&#x27;: -1.19, &#x27;CP5&#x27;: 0.61, &#x27;CP3&#x27;: -0.80, &#x27;CP1&#x27;: 2.36, &#x27;P1&#x27;: -0.74, &#x27;P3&#x27;: 0.72,&#x27;P5&#x27;: 0.93, &#x27;Pz&#x27;: -1.46, &#x27;CPz&#x27;: -0.12, &#x27;Cz&#x27;: 1.074,&#x27;C5&#x27;:2.34,&#x27;C2&#x27;: 1.04, &#x27;C4&#x27;: -0.065, &#x27;C6&#x27;: -0.52, &#x27;CP2&#x27;: 0.37, &#x27;CP4&#x27;: 1.30, &#x27;CP6&#x27;: 0.94&#125; 5.3 对字典的值进行归一化 123456789101112norMyWeiht = myWeight.copy()# Step 1: 获取需要归一化的值values = [v for v in norMyWeiht.values()]# Step 2: 找到最小值和最大值min_value = min(values)max_value = max(values)# Step 3: 对值进行归一化计算for key, value in norMyWeiht.items(): normalized_value = (value - min_value) / (max_value - min_value) norMyWeiht[key] = normalized_value 5.4 根据脑地形图导联顺序重构标准化后的矩阵，将未被选择的导联值置为0 123456789print(&#x27;脑地形图矩阵导联顺序:&#x27;,chLa_index_64)# 重构自定义矩阵顺序reNorMyWeight = []for key in chLa_index_64: if key in norMyWeiht: val = norMyWeiht[key] reNorMyWeight.append(val) else: reNorMyWeight.append(0) 5.5 TopoMap可视化 5.5.1 创建info 12345info = mne.create_info( ch_names = chLa_index_64.tolist(), ch_types = [&#x27;eeg&#x27;]*len(reNorMyWeight), # 通道个数 sfreq = 1000) # 采样频率info.set_montage(biosemi_montage) 5.5.2 可视化 123456789im, cn = mne.viz.plot_topomap(reNorMyWeight, info, names = chLa_index_64, cmap = &#x27;jet&#x27; # vlim=(-2, 2) )plt.colorbar(im)plt.title(&#x27;My Montage&#x27;)plt.show() 6、代码下载 https://github.com/weisihong9/EEG_TopoMap.git","categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"},{"name":"BEAM","slug":"EEG/BEAM","permalink":"https://weisihong9.github.io/categories/EEG/BEAM/"}],"tags":[{"name":"BEAM","slug":"BEAM","permalink":"https://weisihong9.github.io/tags/BEAM/"}]},{"title":"Using_Markdown_writing","slug":"Using_Markdown_writing","date":"2023-05-21T08:54:43.000Z","updated":"2023-05-21T10:05:27.012Z","comments":true,"path":"2023/05/21/Using_Markdown_writing/","link":"","permalink":"https://weisihong9.github.io/2023/05/21/Using_Markdown_writing/","excerpt":"","text":"这是一级标题 下面开始说明如何使用markdown进行写作 这是二级标题 这是正文 换一行？ （在上一行后面按两次空格，再回车就是换一行） 换一段（按两次换行就是换一段） 1 强调 加粗了: 前后各加两个*号 斜体：前后各加一个星号 2 列表 自动编号：数字 + 点 + 空格即可 来一个二级标题 按一下回车，再tab就行 再来一个三级标题 按回车，再按tab 继续回车，再tab 3 插入图片：图床上传图片 把图片先上传到自己的图床，然后复制生成的图片链接。 格式为：!+[图片名字]+(http:\\……png) 图片注释 或者： 4 数学公式 lim⁡x→∞sin(x)x=1\\lim_{x \\to \\infin}\\frac{sin(x)}{x}=1 x→∞lim​xsin(x)​=1 在一段文字中插入公式: lim⁡x→∞f(x)\\lim_{x \\to \\infin}f(x)limx→∞​f(x), command + m 快捷键连按两次就可以生成4个美元符号然后输入公式 5 表格 EMD HHT HHSA 1 2 3 左对其 居中对齐 右对齐 调整编辑部分表格格式快捷键： 先选中表格内容，然后：Alt（fn+option） + shift + f 6 插入链接 复制网址，然后选中要给超链接的文字，直接：command + v 就行 这是一个laTex的链接 7 code 英文的三个小点：1左边的那个键 1234import numpy as npfrom PyEMD import EMDimport matplotlib.pyplot as plt 8 导航 9 将md文件导出为pdf 首先下载这个插件：Markdown Preview Enhanced 然后 command + shift + v 打开 Preview **.md 界面 最后在 Preview **.md 界面，右键，然后选中：Chrome(Puppeteer) --&gt; PDF 即可 10 这是该md文件的下载链接！","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://weisihong9.github.io/tags/Markdown/"}]},{"title":"EMD","slug":"EMD","date":"2023-05-20T16:58:43.000Z","updated":"2023-05-21T15:59:47.986Z","comments":true,"path":"2023/05/21/EMD/","link":"","permalink":"https://weisihong9.github.io/2023/05/21/EMD/","excerpt":"","text":"目的：利用python自带的 pyEMD 实现 经验模态分解（EMD） 1 加载python库 123import numpy as npfrom PyEMD import EMDimport matplotlib.pyplot as plt 2 EMD分解 12345678910111213141516171819202122# 生成示例信号t = np.linspace(0, 1, 1000)signal = np.sin(5 * 2 * np.pi * t) + np.sin(10 * 2 * np.pi * t)# 创建EMD对象emd = EMD()# 执行EMD分解IMFs = emd(signal)# 绘制分解后的IMFsplt.figure(figsize=(10, 6),dpi=600)plt.subplot(len(IMFs) + 1, 1, 1)plt.plot(t, signal, &#x27;b&#x27;)plt.title(&#x27;Original Signal&#x27;)for i, IMF in enumerate(IMFs): plt.subplot(len(IMFs) + 1, 1, i + 2) plt.plot(t, IMF, &#x27;r&#x27;) plt.title(&#x27;IMF %d&#x27; % (i + 1))plt.tight_layout()plt.show() 3 结束","categories":[{"name":"Signal processing","slug":"Signal-processing","permalink":"https://weisihong9.github.io/categories/Signal-processing/"},{"name":"EMD","slug":"Signal-processing/EMD","permalink":"https://weisihong9.github.io/categories/Signal-processing/EMD/"}],"tags":[{"name":"EMD","slug":"EMD","permalink":"https://weisihong9.github.io/tags/EMD/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-05-20T10:35:24.631Z","updated":"2023-05-20T10:35:24.632Z","comments":true,"path":"2023/05/20/hello-world/","link":"","permalink":"https://weisihong9.github.io/2023/05/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"EEG","slug":"EEG","permalink":"https://weisihong9.github.io/categories/EEG/"},{"name":"BEAM","slug":"EEG/BEAM","permalink":"https://weisihong9.github.io/categories/EEG/BEAM/"},{"name":"Signal processing","slug":"Signal-processing","permalink":"https://weisihong9.github.io/categories/Signal-processing/"},{"name":"EMD","slug":"Signal-processing/EMD","permalink":"https://weisihong9.github.io/categories/Signal-processing/EMD/"}],"tags":[{"name":"CFC","slug":"CFC","permalink":"https://weisihong9.github.io/tags/CFC/"},{"name":"BEAM","slug":"BEAM","permalink":"https://weisihong9.github.io/tags/BEAM/"},{"name":"Markdown","slug":"Markdown","permalink":"https://weisihong9.github.io/tags/Markdown/"},{"name":"EMD","slug":"EMD","permalink":"https://weisihong9.github.io/tags/EMD/"}]}